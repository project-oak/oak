/// The Transparent Release attachment for Oak Stage 0. Measurements
/// are produced with
/// <https://github.com/project-oak/oak/snp_measurement.>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirmwareAttachment {
    /// Maps number of vCPUs to measurement of the modified firmware binary.
    #[prost(btree_map = "int32, message", tag = "1")]
    pub configs: ::prost::alloc::collections::BTreeMap<i32, super::super::HexDigest>,
}
/// The Transparent Release attachment for Oak Containers Linux kernel.
/// Measurements are produced with
/// <https://github.com/project-oak/oak/oak_kernel_measurement.>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelAttachment {
    /// Digest of the kernel image part of the bzImage.
    #[prost(message, optional, tag = "1")]
    pub image: ::core::option::Option<super::super::HexDigest>,
    /// Digest of the setup data part of the bzImage.
    #[prost(message, optional, tag = "2")]
    pub setup_data: ::core::option::Option<super::super::HexDigest>,
}
/// Evidence generated by the Layer0.
///
/// Since this layer is the initial layer for our architecture and it is
/// measured during boot, its identity is represented by an attestation report.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RootLayerEvidence {
    /// The platform providing the attestation report.
    #[prost(enumeration = "TeePlatform", tag = "1")]
    pub platform: i32,
    /// TEE-specific attestation report acting as a non-standard certificate for
    /// the Layer0 ECA public key.
    #[prost(bytes = "vec", tag = "2")]
    pub remote_attestation_report: ::prost::alloc::vec::Vec<u8>,
    /// Serialized ECA public key for Layer0 that is signed by the remote
    /// attestation report.
    ///
    /// Represented as a SEC1 encoded point.
    /// <<https://www.secg.org/sec1-v2.pdf#page=16>>
    #[prost(bytes = "vec", tag = "3")]
    pub eca_public_key: ::prost::alloc::vec::Vec<u8>,
}
/// DICE layer evidence containing a certificate signed by the previous layer.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LayerEvidence {
    /// Certificate signing current layer's measurements and the ECA key.
    ///
    /// Represented as a CBOR/COSE/CWT ECA certificate.
    /// <<https://www.rfc-editor.org/rfc/rfc8392.html>>
    #[prost(bytes = "vec", tag = "1")]
    pub eca_certificate: ::prost::alloc::vec::Vec<u8>,
}
/// Keys used by the application to derive encryption session keys and to sign
/// arbitrary data. Each of the certificates contains the final layer's
/// measurement as additional claims.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationKeys {
    /// Certificate signing the encryption public key.
    ///
    /// Represented as a CBOR/COSE/CWT ECA certificate.
    /// <<https://www.rfc-editor.org/rfc/rfc8392.html>>
    #[prost(bytes = "vec", tag = "1")]
    pub encryption_public_key_certificate: ::prost::alloc::vec::Vec<u8>,
    /// Certificate signing the signing public key.
    ///
    /// Represented as a CBOR/COSE/CWT ECA certificate.
    /// <<https://www.rfc-editor.org/rfc/rfc8392.html>>
    #[prost(bytes = "vec", tag = "2")]
    pub signing_public_key_certificate: ::prost::alloc::vec::Vec<u8>,
    /// Certificate signing the group encryption public key as part of Key
    /// Provisioning.
    ///
    /// Represented as a CBOR/COSE/CWT ECA certificate.
    /// <<https://www.rfc-editor.org/rfc/rfc8392.html>>
    #[prost(bytes = "vec", tag = "3")]
    pub group_encryption_public_key_certificate: ::prost::alloc::vec::Vec<u8>,
    /// Certificate signing the group signing public key as part of Key
    /// Provisioning.
    ///
    /// Represented as a CBOR/COSE/CWT ECA certificate.
    /// <<https://www.rfc-editor.org/rfc/rfc8392.html>>
    #[prost(bytes = "vec", tag = "4")]
    pub group_signing_public_key_certificate: ::prost::alloc::vec::Vec<u8>,
}
/// Attestation Evidence used by the client to the identity of firmware and
/// software running inside a Trusted Execution Environment.
///
/// The name is chosen to match the RATS terminology:
/// <<https://datatracker.ietf.org/doc/html/rfc9334#name-evidence>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Evidence {
    /// Layer0 attestation evidence.
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerEvidence>,
    /// Layer1..LayerN-1 attestation evidence.
    #[prost(message, repeated, tag = "2")]
    pub layers: ::prost::alloc::vec::Vec<LayerEvidence>,
    /// Application keys signed by the penultimate layerâ€™s ECA key.
    ///
    /// We are not signing these keys with the last layer's ECA key, because it
    /// is the application layer and the these keys are never shared with it.
    /// The last layer uses an API to the previous layer to:
    /// - Derive session keys from the encryption key
    /// - Sign arbitrary data with the signing key
    #[prost(message, optional, tag = "3")]
    pub application_keys: ::core::option::Option<ApplicationKeys>,
}
/// This proto defines the layered DICE Attestation Evidence.
///
/// DICE provides a mechanism for combining software measurements and
/// corresponding certificates into a chain, where each element (called layer)
/// represents a piece of software loaded into the VMs memory. These layers are
/// loaded sequentially, i.e. the previous layer loads the next layer. The
/// previous layer is also responsible for measuring the next layer, generating
/// a private key and a certificate for it.
///
/// <<https://trustedcomputinggroup.org/wp-content/uploads/TCG_DICE_Attestation_Architecture_r22_02dec2020.pdf>>
/// <<https://trustedcomputinggroup.org/wp-content/uploads/DICE-Layering-Architecture-r19_pub.pdf>>
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TeePlatform {
    Unspecified = 0,
    AmdSevSnp = 1,
    IntelTdx = 2,
    None = 3,
}
impl TeePlatform {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TeePlatform::Unspecified => "TEE_PLATFORM_UNSPECIFIED",
            TeePlatform::AmdSevSnp => "AMD_SEV_SNP",
            TeePlatform::IntelTdx => "INTEL_TDX",
            TeePlatform::None => "TEE_PLATFORM_NONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEE_PLATFORM_UNSPECIFIED" => Some(Self::Unspecified),
            "AMD_SEV_SNP" => Some(Self::AmdSevSnp),
            "INTEL_TDX" => Some(Self::IntelTdx),
            "TEE_PLATFORM_NONE" => Some(Self::None),
            _ => None,
        }
    }
}
/// Message for passing embedded certificate authority information between
/// layers. Will never appear in the evidence that is sent to the client.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CertificateAuthority {
    /// ECA private key that will be used by a layer to sign a certificate for the
    /// next layer.
    #[prost(bytes = "vec", tag = "1")]
    pub eca_private_key: ::prost::alloc::vec::Vec<u8>,
}
/// Message that is sent between DICE layers.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiceData {
    #[prost(message, optional, tag = "1")]
    pub evidence: ::core::option::Option<Evidence>,
    #[prost(message, optional, tag = "2")]
    pub certificate_authority: ::core::option::Option<CertificateAuthority>,
}
/// Endorsement for binaries from the Transparent Release process.
/// <<https://github.com/project-oak/oak/blob/main/docs/release.md>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransparentReleaseEndorsement {
    /// JSON string comtaining the endorsement statement for the underlying binary.
    /// The format is described here:
    /// <https://github.com/project-oak/transparent-release/blob/main/docs/claim-transparency.md#the-claim-format>
    #[prost(bytes = "vec", tag = "1")]
    pub endorsement: ::prost::alloc::vec::Vec<u8>,
    /// The data hashed as endorsement subject can be inlined here when needed.
    /// Can be the binary or the attachment, depending on the usage specified
    /// in the endorsement.
    #[prost(bytes = "vec", tag = "4")]
    pub subject: ::prost::alloc::vec::Vec<u8>,
    /// The signature for the endorsement.
    #[prost(bytes = "vec", tag = "2")]
    pub endorsement_signature: ::prost::alloc::vec::Vec<u8>,
    /// The log entry as proof of inclusion of the endorsement statement in Rekor.
    #[prost(bytes = "vec", tag = "3")]
    pub rekor_log_entry: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RootLayerEndorsements {
    /// The serialized TEE certificate(s). The details of the format and how the
    /// certificate(s) are encoded into this byte array are implementation
    /// specific. In case of AMD-SEV-SNP, as described in
    /// <https://www.amd.com/system/files/TechDocs/57230.pdf,> there are three
    /// different certificates packaged in two different files. We only include
    /// the machine-specific VCEK certificate since the AMD Root Key (ARK) and
    /// AMD SEV Key (ASK) are long-lived.
    #[prost(bytes = "vec", tag = "1")]
    pub tee_certificate: ::prost::alloc::vec::Vec<u8>,
    /// Endorsement of the Stage0 binary.
    #[prost(message, optional, tag = "2")]
    pub stage0: ::core::option::Option<TransparentReleaseEndorsement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelLayerEndorsements {
    #[prost(message, optional, tag = "1")]
    pub kernel: ::core::option::Option<TransparentReleaseEndorsement>,
    #[prost(message, optional, tag = "2")]
    pub kernel_cmd_line: ::core::option::Option<TransparentReleaseEndorsement>,
    #[prost(message, optional, tag = "4")]
    pub init_ram_fs: ::core::option::Option<TransparentReleaseEndorsement>,
    #[prost(message, optional, tag = "5")]
    pub memory_map: ::core::option::Option<TransparentReleaseEndorsement>,
    #[prost(message, optional, tag = "6")]
    pub acpi: ::core::option::Option<TransparentReleaseEndorsement>,
    /// Field is deprecated and kept only for backwards compatibility. Remove ASAP.
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub kernel_image: ::core::option::Option<TransparentReleaseEndorsement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemLayerEndorsements {
    #[prost(message, optional, tag = "1")]
    pub system_image: ::core::option::Option<TransparentReleaseEndorsement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationLayerEndorsements {
    #[prost(message, optional, tag = "1")]
    pub binary: ::core::option::Option<TransparentReleaseEndorsement>,
    #[prost(message, optional, tag = "2")]
    pub configuration: ::core::option::Option<TransparentReleaseEndorsement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerLayerEndorsements {
    #[prost(message, optional, tag = "1")]
    pub binary: ::core::option::Option<TransparentReleaseEndorsement>,
    #[prost(message, optional, tag = "2")]
    pub configuration: ::core::option::Option<TransparentReleaseEndorsement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OakRestrictedKernelEndorsements {
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerEndorsements>,
    #[prost(message, optional, tag = "2")]
    pub kernel_layer: ::core::option::Option<KernelLayerEndorsements>,
    #[prost(message, optional, tag = "3")]
    pub application_layer: ::core::option::Option<ApplicationLayerEndorsements>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OakContainersEndorsements {
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerEndorsements>,
    #[prost(message, optional, tag = "2")]
    pub kernel_layer: ::core::option::Option<KernelLayerEndorsements>,
    #[prost(message, optional, tag = "3")]
    pub system_layer: ::core::option::Option<SystemLayerEndorsements>,
    #[prost(message, optional, tag = "4")]
    pub container_layer: ::core::option::Option<ContainerLayerEndorsements>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CbEndorsements {
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerEndorsements>,
}
/// Endorsement contains statements that some entity (e.g. a hardware provider)
/// vouches for the integrity of claims about the TEE or the software running
/// on it.
///
/// The name is chosen to match the RATS terminology:
/// <<https://www.rfc-editor.org/rfc/rfc9334.html#name-endorsements>>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Endorsements {
    #[prost(oneof = "endorsements::Type", tags = "1, 2, 3")]
    pub r#type: ::core::option::Option<endorsements::Type>,
}
/// Nested message and enum types in `Endorsements`.
pub mod endorsements {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        OakRestrictedKernel(super::OakRestrictedKernelEndorsements),
        #[prost(message, tag = "2")]
        OakContainers(super::OakContainersEndorsements),
        #[prost(message, tag = "3")]
        Cb(super::CbEndorsements),
    }
}
/// The versions of the components in the AMD SEV-SNP platform Trusted Compute
/// Base (TCB).
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TcbVersion {
    /// The current security version number (SVN) of the secure processor (PSP)
    /// bootloader.
    #[prost(uint32, tag = "1")]
    pub boot_loader: u32,
    /// The current SVN of the PSP operating system.
    #[prost(uint32, tag = "2")]
    pub tee: u32,
    /// The current SVN of the SNP firmware.
    #[prost(uint32, tag = "3")]
    pub snp: u32,
    /// The lowest current patch level of all the CPU cores.
    #[prost(uint32, tag = "4")]
    pub microcode: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerificationSkipped {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawDigests {
    #[prost(message, repeated, tag = "1")]
    pub digests: ::prost::alloc::vec::Vec<super::super::RawDigest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpectedDigests {
    #[prost(oneof = "expected_digests::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<expected_digests::Type>,
}
/// Nested message and enum types in `ExpectedDigests`.
pub mod expected_digests {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// If the reference value was set to SkipVerification, we represent that
        /// here.
        #[prost(message, tag = "1")]
        Skipped(super::VerificationSkipped),
        /// One or more digests that should be considered a valid match against an
        /// actual value.
        #[prost(message, tag = "2")]
        Digests(super::RawDigests),
    }
}
/// The expected values for kernel image and setup data, computed from previously
/// provided endorsements and reference values.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelExpectedValues {
    /// Allowable digests for the image.
    #[prost(message, optional, tag = "1")]
    pub image: ::core::option::Option<ExpectedDigests>,
    /// Allowable digests for the setup data.
    #[prost(message, optional, tag = "2")]
    pub setup_data: ::core::option::Option<ExpectedDigests>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AmdSevExpectedValues {
    #[prost(message, optional, tag = "1")]
    pub stage0_expected: ::core::option::Option<ExpectedDigests>,
    /// Minimum accepted versions of all TCB components.
    #[prost(message, optional, tag = "2")]
    pub min_tcb_version: ::core::option::Option<TcbVersion>,
    /// If true, will skip the check that the TEE is not in debug mode.
    #[prost(bool, tag = "3")]
    pub allow_debug: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntelTdxExpectedValues {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsecureExpectedValues {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpectedRegex {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpectedStringLiterals {
    #[prost(string, repeated, tag = "1")]
    pub value: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextExpectedValue {
    #[prost(oneof = "text_expected_value::Type", tags = "1, 2, 3")]
    pub r#type: ::core::option::Option<text_expected_value::Type>,
}
/// Nested message and enum types in `TextExpectedValue`.
pub mod text_expected_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// If the reference value was set to SkipVerification, we represent that
        /// here.
        #[prost(message, tag = "1")]
        Skipped(super::VerificationSkipped),
        #[prost(message, tag = "2")]
        Regex(super::ExpectedRegex),
        #[prost(message, tag = "3")]
        StringLiterals(super::ExpectedStringLiterals),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RootLayerExpectedValues {
    /// Switches between AMD SEV-SNP and Intel TDX based on TeePlatform value.
    /// Verification is skipped when not running in a TEE.
    #[prost(message, optional, tag = "1")]
    pub amd_sev: ::core::option::Option<AmdSevExpectedValues>,
    #[prost(message, optional, tag = "2")]
    pub intel_tdx: ::core::option::Option<IntelTdxExpectedValues>,
    /// When insecure is set no verification of the TEE platform is performed. This
    /// can be used when not running in a TEE or when the client is agnostic about
    /// the platform and doesn't care about the hardware verification.
    #[prost(message, optional, tag = "3")]
    pub insecure: ::core::option::Option<InsecureExpectedValues>,
}
/// Reference values of the kernel layer, as measured by stage0.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelLayerExpectedValues {
    /// Verifies the kernel based on endorsement.
    #[prost(message, optional, tag = "1")]
    pub kernel: ::core::option::Option<KernelExpectedValues>,
    /// Verifies the kernel command line, i.e. the parameters passed to the
    /// kernel on boot.
    #[prost(message, optional, tag = "2")]
    pub kernel_cmd_line_text: ::core::option::Option<TextExpectedValue>,
    /// Verifies the stage1 binary if running as Oak Containers.
    #[prost(message, optional, tag = "3")]
    pub init_ram_fs: ::core::option::Option<ExpectedDigests>,
    #[prost(message, optional, tag = "4")]
    pub memory_map: ::core::option::Option<ExpectedDigests>,
    #[prost(message, optional, tag = "5")]
    pub acpi: ::core::option::Option<ExpectedDigests>,
}
/// The expected binary digests for a system layer image.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemLayerExpectedValues {
    /// The allowable digest values for a system layer image.
    #[prost(message, optional, tag = "1")]
    pub system_image: ::core::option::Option<ExpectedDigests>,
}
/// The expected bundle and configuration digests for a container layer.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerLayerExpectedValues {
    /// The allowable digest values for a container bundle.
    #[prost(message, optional, tag = "1")]
    pub bundle: ::core::option::Option<ExpectedDigests>,
    /// The allowable digest values for a configuration passed into a container.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<ExpectedDigests>,
}
/// The expected binary and configuration digests for an application layer.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationLayerExpectedValues {
    /// The allowable digest values for an application binary.
    #[prost(message, optional, tag = "1")]
    pub binary: ::core::option::Option<ExpectedDigests>,
    /// The allowable digest values for a configuration passed to the application
    /// binary.
    #[prost(message, optional, tag = "2")]
    pub configuration: ::core::option::Option<ExpectedDigests>,
}
/// Represents digest of application task config.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CbApplicationLayerExpectedValues {
    /// Verifies the application task config.
    #[prost(message, optional, tag = "1")]
    pub binary: ::core::option::Option<ExpectedDigests>,
}
/// Represents digest of application task config.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CbSystemLayerExpectedValues {
    /// Verifies the application task config.
    #[prost(message, optional, tag = "1")]
    pub system_image: ::core::option::Option<ExpectedDigests>,
    #[prost(message, optional, tag = "2")]
    pub system_cmd_line: ::core::option::Option<TextExpectedValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OakRestrictedKernelExpectedValues {
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerExpectedValues>,
    #[prost(message, optional, tag = "2")]
    pub kernel_layer: ::core::option::Option<KernelLayerExpectedValues>,
    #[prost(message, optional, tag = "3")]
    pub application_layer: ::core::option::Option<ApplicationLayerExpectedValues>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OakContainersExpectedValues {
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerExpectedValues>,
    #[prost(message, optional, tag = "2")]
    pub kernel_layer: ::core::option::Option<KernelLayerExpectedValues>,
    #[prost(message, optional, tag = "3")]
    pub system_layer: ::core::option::Option<SystemLayerExpectedValues>,
    #[prost(message, optional, tag = "4")]
    pub container_layer: ::core::option::Option<ContainerLayerExpectedValues>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CbExpectedValues {
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerExpectedValues>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpectedValues {
    #[prost(oneof = "expected_values::Type", tags = "1, 2, 3")]
    pub r#type: ::core::option::Option<expected_values::Type>,
}
/// Nested message and enum types in `ExpectedValues`.
pub mod expected_values {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        OakRestrictedKernel(super::OakRestrictedKernelExpectedValues),
        #[prost(message, tag = "2")]
        OakContainers(super::OakContainersExpectedValues),
        #[prost(message, tag = "3")]
        Cb(super::CbExpectedValues),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkipVerification {}
/// Verifies the transparency log entry, including signatures and the digest.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndorsementReferenceValue {
    /// The endorser's public signing key for signature verification.
    #[prost(bytes = "vec", tag = "1")]
    pub endorser_public_key: ::prost::alloc::vec::Vec<u8>,
    /// Rekor's public signing key for signature verification.
    #[prost(bytes = "vec", tag = "2")]
    pub rekor_public_key: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinaryReferenceValue {
    #[prost(oneof = "binary_reference_value::Type", tags = "1, 2, 3")]
    pub r#type: ::core::option::Option<binary_reference_value::Type>,
}
/// Nested message and enum types in `BinaryReferenceValue`.
pub mod binary_reference_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// Deliberately skips a verification step, rather than failing. For example:
        ///      root_layer { stage0 { skip {} } }
        /// will skip the verification, contrasting
        ///      root_layer { stage0 {} }
        /// which will make the verification fail.
        #[prost(message, tag = "1")]
        Skip(super::SkipVerification),
        /// Verifies the endorsement of the underlying binary.
        #[prost(message, tag = "2")]
        Endorsement(super::EndorsementReferenceValue),
        /// Explicitly verifies digests if the client has them.
        #[prost(message, tag = "3")]
        Digests(super::Digests),
    }
}
/// Similar to the `Digests` message, but allows to specify digests for the
/// split components of the bzImage separately.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelDigests {
    /// Contains admissible digests for the kernel image part of the kernel.
    #[prost(message, optional, tag = "2")]
    pub image: ::core::option::Option<Digests>,
    /// Contains admissible digests for the setup data part of the kernel.
    #[prost(message, optional, tag = "3")]
    pub setup_data: ::core::option::Option<Digests>,
}
/// Follows the lines of `BinaryReferenceValue`, but provides a custom proto
/// to facilitate the digest matching.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelBinaryReferenceValue {
    #[prost(oneof = "kernel_binary_reference_value::Type", tags = "1, 2, 3")]
    pub r#type: ::core::option::Option<kernel_binary_reference_value::Type>,
}
/// Nested message and enum types in `KernelBinaryReferenceValue`.
pub mod kernel_binary_reference_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        Skip(super::SkipVerification),
        #[prost(message, tag = "2")]
        Endorsement(super::EndorsementReferenceValue),
        #[prost(message, tag = "3")]
        Digests(super::KernelDigests),
    }
}
/// Reference value for a file including its digests.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileReferenceValue {
    /// Allowable digests for the file.
    #[prost(message, optional, tag = "1")]
    pub digests: ::core::option::Option<Digests>,
    /// Absolute path to the file in question, or just the file name. Relative
    /// paths are not supported.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
/// Verifies that a particular string is equal to at least one of the specified
/// ones. No checks are performed if this is empty.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringReferenceValue {
    #[prost(string, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Regex {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
/// A match in at least one value is considered a success. At least one value
/// must be specified, otherwise verification fails.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringLiterals {
    #[prost(string, repeated, tag = "1")]
    pub value: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegexReferenceValue {
    #[prost(oneof = "regex_reference_value::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<regex_reference_value::Type>,
}
/// Nested message and enum types in `RegexReferenceValue`.
pub mod regex_reference_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        Skip(super::SkipVerification),
        #[prost(message, tag = "2")]
        Regex(super::Regex),
    }
}
/// Reference value to match text via endorsement, or directly via constants
/// or a regular expression.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextReferenceValue {
    #[prost(oneof = "text_reference_value::Type", tags = "1, 4, 2, 3")]
    pub r#type: ::core::option::Option<text_reference_value::Type>,
}
/// Nested message and enum types in `TextReferenceValue`.
pub mod text_reference_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        Skip(super::SkipVerification),
        #[prost(message, tag = "4")]
        Endorsement(super::EndorsementReferenceValue),
        #[prost(message, tag = "2")]
        Regex(super::Regex),
        #[prost(message, tag = "3")]
        StringLiterals(super::StringLiterals),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RootLayerReferenceValues {
    /// Switches between AMD SEV-SNP and Intel TDX based on TeePlatform value.
    /// Verification is skipped when not running in a TEE.
    #[prost(message, optional, tag = "1")]
    pub amd_sev: ::core::option::Option<AmdSevReferenceValues>,
    #[prost(message, optional, tag = "2")]
    pub intel_tdx: ::core::option::Option<IntelTdxReferenceValues>,
    /// When insecure is set no verification of the TEE platform is performed. This
    /// can be used when not running in a TEE or when the client is agnostic about
    /// the platform and doesn't care about the hardware verification.
    #[prost(message, optional, tag = "3")]
    pub insecure: ::core::option::Option<InsecureReferenceValues>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AmdSevReferenceValues {
    /// Minimum accepted versions of all TCB components.
    #[prost(message, optional, tag = "5")]
    pub min_tcb_version: ::core::option::Option<TcbVersion>,
    /// If true, will skip the check that the TEE is not in debug mode.
    #[prost(bool, tag = "3")]
    pub allow_debug: bool,
    /// Verifies the stage0 binary implicitly contained in the root layer.
    #[prost(message, optional, tag = "4")]
    pub stage0: ::core::option::Option<BinaryReferenceValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntelTdxReferenceValues {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsecureReferenceValues {}
/// Verifies that the field contains at least one of the given digests.
/// No checks are performed if this is empty. A match in at least one
/// digest is considered a success.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Digests {
    #[prost(message, repeated, tag = "1")]
    pub digests: ::prost::alloc::vec::Vec<super::super::RawDigest>,
}
/// Reference values of the kernel layer, as measured by stage0.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelLayerReferenceValues {
    /// Verifies the kernel based on endorsement.
    #[prost(message, optional, tag = "1")]
    pub kernel: ::core::option::Option<KernelBinaryReferenceValue>,
    /// Verifies the kernel command line, i.e. the parameters passed to the
    /// kernel on boot.
    #[prost(message, optional, tag = "9")]
    pub kernel_cmd_line_text: ::core::option::Option<TextReferenceValue>,
    /// Fields are deprecated and kept only for backwards compatibility. They are
    /// not being used by the verifier. Remove ASAP.
    #[deprecated]
    #[prost(message, optional, tag = "3")]
    pub kernel_setup_data: ::core::option::Option<BinaryReferenceValue>,
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub kernel_image: ::core::option::Option<BinaryReferenceValue>,
    #[deprecated]
    #[prost(message, optional, tag = "8")]
    pub kernel_cmd_line_regex: ::core::option::Option<RegexReferenceValue>,
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub kernel_cmd_line: ::core::option::Option<BinaryReferenceValue>,
    /// Verifies the stage1 binary if running as Oak Containers.
    #[prost(message, optional, tag = "4")]
    pub init_ram_fs: ::core::option::Option<BinaryReferenceValue>,
    #[prost(message, optional, tag = "5")]
    pub memory_map: ::core::option::Option<BinaryReferenceValue>,
    #[prost(message, optional, tag = "6")]
    pub acpi: ::core::option::Option<BinaryReferenceValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemLayerReferenceValues {
    /// Verifies the system image binary based on endorsement.
    #[prost(message, optional, tag = "1")]
    pub system_image: ::core::option::Option<BinaryReferenceValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CbSystemLayerReferenceValues {
    /// Verifies the system image binary.
    #[prost(message, optional, tag = "1")]
    pub system_image: ::core::option::Option<BinaryReferenceValue>,
    /// Verifies the command line by which the system image was built.
    #[prost(message, optional, tag = "2")]
    pub system_cmd_line: ::core::option::Option<StringReferenceValue>,
}
/// Represents an application running under Oak Restricted Kernel.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationLayerReferenceValues {
    /// Verifies the application binary based on endorsement.
    #[prost(message, optional, tag = "1")]
    pub binary: ::core::option::Option<BinaryReferenceValue>,
    /// Verifies configuration with respect to the application binary.
    #[prost(message, optional, tag = "2")]
    pub configuration: ::core::option::Option<BinaryReferenceValue>,
}
/// Represents digest of application task config.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CbApplicationLayerReferenceValues {
    /// Verifies the application task config.
    #[prost(message, optional, tag = "1")]
    pub binary: ::core::option::Option<BinaryReferenceValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerLayerReferenceValues {
    /// Verifies the container binary based on endorsement.
    #[prost(message, optional, tag = "1")]
    pub binary: ::core::option::Option<BinaryReferenceValue>,
    /// Verifies configuration with respect to the container binary.
    #[prost(message, optional, tag = "2")]
    pub configuration: ::core::option::Option<BinaryReferenceValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OakRestrictedKernelReferenceValues {
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerReferenceValues>,
    #[prost(message, optional, tag = "2")]
    pub kernel_layer: ::core::option::Option<KernelLayerReferenceValues>,
    #[prost(message, optional, tag = "3")]
    pub application_layer: ::core::option::Option<ApplicationLayerReferenceValues>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OakContainersReferenceValues {
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerReferenceValues>,
    #[prost(message, optional, tag = "2")]
    pub kernel_layer: ::core::option::Option<KernelLayerReferenceValues>,
    #[prost(message, optional, tag = "3")]
    pub system_layer: ::core::option::Option<SystemLayerReferenceValues>,
    #[prost(message, optional, tag = "4")]
    pub container_layer: ::core::option::Option<ContainerLayerReferenceValues>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CbReferenceValues {
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerReferenceValues>,
    #[prost(message, optional, tag = "2")]
    pub kernel_layer: ::core::option::Option<KernelLayerReferenceValues>,
    #[prost(message, optional, tag = "3")]
    pub system_layer: ::core::option::Option<CbSystemLayerReferenceValues>,
    #[prost(message, optional, tag = "4")]
    pub application_layer: ::core::option::Option<CbApplicationLayerReferenceValues>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReferenceValues {
    #[prost(oneof = "reference_values::Type", tags = "1, 2, 3")]
    pub r#type: ::core::option::Option<reference_values::Type>,
}
/// Nested message and enum types in `ReferenceValues`.
pub mod reference_values {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        OakRestrictedKernel(super::OakRestrictedKernelReferenceValues),
        #[prost(message, tag = "2")]
        OakContainers(super::OakContainersReferenceValues),
        #[prost(message, tag = "3")]
        Cb(super::CbReferenceValues),
    }
}
/// Represents a verification result. Can be extended to return certain
/// measurements and other detail to the client for further processing.
/// Nomenclature follows RFC 9334.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttestationResults {
    /// Indicates whether the verification passed and perhaps more.
    #[prost(enumeration = "attestation_results::Status", tag = "1")]
    pub status: i32,
    /// Provides the reason why verification did not pass, on non-success status.
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    /// Contains the verified public key for encryption whenever the status
    /// indicates success. The key is serialized as an X25519 octet string.
    ///
    /// Deprecated: will be replaced by the
    /// `extracted_evidence.encryption_public_key` field. For now both are
    /// populated.
    #[deprecated]
    #[prost(bytes = "vec", tag = "3")]
    pub encryption_public_key: ::prost::alloc::vec::Vec<u8>,
    /// Contains the verified public key for signing whenever the status
    /// indicates success. The key is serialized using the SEC 1
    /// Elliptic-Curve-Point-to-Octet-String conversion.
    ///
    /// Deprecated: will be replaced by the `extracted_evidence.signing_public_key`
    /// field. For now both are populated.
    #[deprecated]
    #[prost(bytes = "vec", tag = "4")]
    pub signing_public_key: ::prost::alloc::vec::Vec<u8>,
    /// Contains the evidence values whenever the status indicates success.
    #[prost(message, optional, tag = "5")]
    pub extracted_evidence: ::core::option::Option<ExtractedEvidence>,
}
/// Nested message and enum types in `AttestationResults`.
pub mod attestation_results {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        Success = 1,
        GenericFailure = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::Unspecified => "STATUS_UNSPECIFIED",
                Status::Success => "STATUS_SUCCESS",
                Status::GenericFailure => "STATUS_GENERIC_FAILURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "STATUS_SUCCESS" => Some(Self::Success),
                "STATUS_GENERIC_FAILURE" => Some(Self::GenericFailure),
                _ => None,
            }
        }
    }
}
/// Evidence values extracted from attestation evidence during verification.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtractedEvidence {
    /// Contains the public key for encryption. The key is serialized as an X25519
    /// octet string.
    #[prost(bytes = "vec", tag = "4")]
    pub encryption_public_key: ::prost::alloc::vec::Vec<u8>,
    /// Contains the public key for signing. The key is serialized using the SEC 1
    /// Elliptic-Curve-Point-to-Octet-String conversion.
    #[prost(bytes = "vec", tag = "5")]
    pub signing_public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "extracted_evidence::EvidenceValues", tags = "1, 2, 3")]
    pub evidence_values: ::core::option::Option<extracted_evidence::EvidenceValues>,
}
/// Nested message and enum types in `ExtractedEvidence`.
pub mod extracted_evidence {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EvidenceValues {
        #[prost(message, tag = "1")]
        OakRestrictedKernel(super::OakRestrictedKernelData),
        #[prost(message, tag = "2")]
        OakContainers(super::OakContainersData),
        #[prost(message, tag = "3")]
        Cb(super::CbData),
    }
}
/// Values extracted from the root layer evidence.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RootLayerData {
    #[prost(oneof = "root_layer_data::Report", tags = "1, 2, 3")]
    pub report: ::core::option::Option<root_layer_data::Report>,
}
/// Nested message and enum types in `RootLayerData`.
pub mod root_layer_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Report {
        /// Values extracted from an AMD SEV-SNP attestation report.
        #[prost(message, tag = "1")]
        SevSnp(super::AmdAttestationReport),
        /// Values extracted from an Intel TDX attestation report.
        #[prost(message, tag = "2")]
        Tdx(super::IntelTdxAttestationReport),
        /// Values extracted from a fake report when not running in a TEE.
        #[prost(message, tag = "3")]
        Fake(super::FakeAttestationReport),
    }
}
/// Values extracted from an AMD SEV-SNP attestation report.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AmdAttestationReport {
    /// The custom bytes that were passed to the report when it was requested.
    #[prost(bytes = "vec", tag = "1")]
    pub report_data: ::prost::alloc::vec::Vec<u8>,
    /// Current TCB Version.
    #[prost(message, optional, tag = "2")]
    pub current_tcb: ::core::option::Option<TcbVersion>,
    /// Reported TCB version (the version can be lower than current_tcb in case of
    /// a provisional update. See
    /// <https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/56860.pdf>
    /// (Section 3.4) for more detail).
    #[prost(message, optional, tag = "7")]
    pub reported_tcb: ::core::option::Option<TcbVersion>,
    /// Whether the VM was booted in debug mode.
    #[prost(bool, tag = "3")]
    pub debug: bool,
    /// The measurement of the initial memory and CPU state of the VM before
    /// startup. This implicitly includes the measurement of the Stage 0 firmware
    /// binary.
    #[prost(bytes = "vec", tag = "4")]
    pub initial_measurement: ::prost::alloc::vec::Vec<u8>,
    /// The hardware ID of the AMD SEV-SNP platform that generated the attestation
    /// report.
    #[prost(bytes = "vec", tag = "5")]
    pub hardware_id: ::prost::alloc::vec::Vec<u8>,
    /// The VM Protection Leve (VMPL) that was active when the attestation report
    /// was generated.
    #[prost(uint32, tag = "6")]
    pub vmpl: u32,
}
/// Values extracted from an Intel TDX attestation report.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntelTdxAttestationReport {
    /// The custom bytes that were passed to the report when it was requested.
    #[prost(bytes = "vec", tag = "1")]
    pub report_data: ::prost::alloc::vec::Vec<u8>,
}
/// Values extracted from a fake attestation report when not running in a TEE.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FakeAttestationReport {
    /// The custom bytes that were passed to the report when it was requested.
    #[prost(bytes = "vec", tag = "1")]
    pub report_data: ::prost::alloc::vec::Vec<u8>,
}
/// Values extracted from the the kernel layer evidence, as measured by stage0.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelLayerData {
    /// Measured digests of the image part of the kernel.
    #[prost(message, optional, tag = "1")]
    pub kernel_image: ::core::option::Option<super::super::RawDigest>,
    /// Measured digests of the setup data part of the kernel.
    #[prost(message, optional, tag = "3")]
    pub kernel_setup_data: ::core::option::Option<super::super::RawDigest>,
    /// Measured digests of the command-line that was passed to the kernel
    /// during startup.
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub kernel_cmd_line: ::core::option::Option<super::super::RawDigest>,
    /// Command-line that was passed to the kernel during startup. If absent,
    /// verification will only succeed with the corresponding reference value set
    /// to skip (for compatibility with the legacy version of the evidence
    /// producing code). Empty value corresponds to the kernel being run with an
    /// empty command line.
    #[prost(string, optional, tag = "7")]
    pub kernel_raw_cmd_line: ::core::option::Option<::prost::alloc::string::String>,
    /// Measured digests of the initial RAM disk.
    #[prost(message, optional, tag = "4")]
    pub init_ram_fs: ::core::option::Option<super::super::RawDigest>,
    /// Measured digests of the physical memory map.
    #[prost(message, optional, tag = "5")]
    pub memory_map: ::core::option::Option<super::super::RawDigest>,
    /// Measured digests of the commands for building the ACPI tables.
    #[prost(message, optional, tag = "6")]
    pub acpi: ::core::option::Option<super::super::RawDigest>,
}
/// Values extracted from the evidence that represents an application running
/// under the Oak Restricted Kernel.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationLayerData {
    /// Measurement RawDigest of the application binary.
    #[prost(message, optional, tag = "1")]
    pub binary: ::core::option::Option<super::super::RawDigest>,
    /// Measurement RawDigest of the application configuration.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<super::super::RawDigest>,
}
/// Values extracted from the evidence that represents the Oak Containers system
/// image.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemLayerData {
    /// Measurement RawDigest of the system image.
    #[prost(message, optional, tag = "1")]
    pub system_image: ::core::option::Option<super::super::RawDigest>,
}
/// Values extracted from the evidence that represents the Container Runtime
/// Bundle used in Oak Containers.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerLayerData {
    /// Measurement RawDigest of the container bundle.
    #[prost(message, optional, tag = "1")]
    pub bundle: ::core::option::Option<super::super::RawDigest>,
    /// Measurement RawDigest of the configuration used by the container.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<super::super::RawDigest>,
}
/// Values extracted from the evidence for a restricted kernel application.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OakRestrictedKernelData {
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerData>,
    #[prost(message, optional, tag = "2")]
    pub kernel_layer: ::core::option::Option<KernelLayerData>,
    #[prost(message, optional, tag = "3")]
    pub application_layer: ::core::option::Option<ApplicationLayerData>,
}
/// Values extracted from the evidence for an Oak Containers instance.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OakContainersData {
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerData>,
    #[prost(message, optional, tag = "2")]
    pub kernel_layer: ::core::option::Option<KernelLayerData>,
    #[prost(message, optional, tag = "3")]
    pub system_layer: ::core::option::Option<SystemLayerData>,
    #[prost(message, optional, tag = "4")]
    pub container_layer: ::core::option::Option<ContainerLayerData>,
}
/// Reserved for future use.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CbData {
    #[prost(message, optional, tag = "1")]
    pub root_layer: ::core::option::Option<RootLayerData>,
}
