// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetKeyProvisioningRoleResponse {
    #[prost(enumeration = "KeyProvisioningRole", tag = "1")]
    pub role: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetGroupKeysResponse {
    #[prost(message, optional, tag = "1")]
    pub group_keys: ::core::option::Option<
        super::super::key_provisioning::v1::GroupKeys,
    >,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyProvisioningRole {
    Unspecified = 0,
    Leader = 1,
    Follower = 2,
}
impl KeyProvisioningRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "KEY_PROVISIONING_ROLE_UNSPECIFIED",
            Self::Leader => "LEADER",
            Self::Follower => "FOLLOWER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KEY_PROVISIONING_ROLE_UNSPECIFIED" => Some(Self::Unspecified),
            "LEADER" => Some(Self::Leader),
            "FOLLOWER" => Some(Self::Follower),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeriveSessionKeysRequest {
    #[prost(enumeration = "KeyOrigin", tag = "1")]
    pub key_origin: i32,
    /// Ephemeral Diffie-Hellman client public key that is needed to derive session
    /// keys.
    #[prost(bytes = "vec", tag = "2")]
    pub serialized_encapsulated_public_key: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeriveSessionKeysResponse {
    /// Session keys for decrypting client requests and encrypting enclave
    /// responses.
    #[prost(message, optional, tag = "1")]
    pub session_keys: ::core::option::Option<super::super::crypto::v1::SessionKeys>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignRequest {
    #[prost(enumeration = "KeyOrigin", tag = "1")]
    pub key_origin: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub message: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignResponse {
    #[prost(message, optional, tag = "1")]
    pub signature: ::core::option::Option<super::super::crypto::v1::Signature>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BindSessionRequest {
    /// Session handshake transcript.
    #[prost(bytes = "vec", tag = "1")]
    pub transcript: ::prost::alloc::vec::Vec<u8>,
    /// Additional data that will be signed alongside the transcript.
    /// I.e. it could be an info string used to prevent confused deputy problems.
    #[prost(bytes = "vec", tag = "2")]
    pub additional_data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BindSessionResponse {
    #[prost(message, optional, tag = "1")]
    pub signature: ::core::option::Option<super::super::crypto::v1::Signature>,
}
/// Choice between a key generated by the enclave instance and the key
/// distributed to the enclave group with Key Provisioning.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyOrigin {
    Unspecified = 0,
    Instance = 1,
    Group = 2,
}
impl KeyOrigin {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "KEY_ORIGIN_UNSPECIFIED",
            Self::Instance => "INSTANCE",
            Self::Group => "GROUP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KEY_ORIGIN_UNSPECIFIED" => Some(Self::Unspecified),
            "INSTANCE" => Some(Self::Instance),
            "GROUP" => Some(Self::Group),
            _ => None,
        }
    }
}
