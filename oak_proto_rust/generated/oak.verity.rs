// This file is @generated by prost-build.
/// Request message containing the input data and Wasm module to execute
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteRequest {
    /// Binary data to operate on
    #[prost(bytes = "vec", tag = "1")]
    pub input_data: ::prost::alloc::vec::Vec<u8>,
    /// Wasm module bytecode to execute
    #[prost(bytes = "vec", tag = "2")]
    pub wasm_module: ::prost::alloc::vec::Vec<u8>,
}
/// Manifest containing digests of all inputs and outputs for verification
/// TODO: b/448322106 - Consider using in-toto or SLSA instead of this protobuf.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionManifest {
    /// Digest of the input data
    #[prost(message, optional, tag = "1")]
    pub input_data_digest: ::core::option::Option<super::RawDigest>,
    /// Digest of the Wasm module
    #[prost(message, optional, tag = "2")]
    pub wasm_module_digest: ::core::option::Option<super::RawDigest>,
    /// Digest of the output data
    #[prost(message, optional, tag = "3")]
    pub output_data_digest: ::core::option::Option<super::RawDigest>,
}
/// Response message containing both the execution manifest and raw output
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteResponse {
    /// Serialized `ExecutionManifest`.
    #[prost(bytes = "vec", tag = "1")]
    pub serialized_manifest: ::prost::alloc::vec::Vec<u8>,
    /// Assertions about the manifest, generated by different assertion generators.
    /// The key is the ID of the assertion generator.
    #[prost(btree_map = "string, message", tag = "2")]
    pub assertions: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        super::attestation::v1::Assertion,
    >,
    /// Raw output bytes from Wasm execution
    #[prost(bytes = "vec", tag = "3")]
    pub output_data: ::prost::alloc::vec::Vec<u8>,
}
