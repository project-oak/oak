// This file is @generated by prost-build.
/// Defines a period of validity between two timestamps.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Validity {
    /// Time when the valid period begins. The timestamp itself is included in
    /// the valid period.
    #[prost(message, optional, tag = "1")]
    pub not_before: ::core::option::Option<::prost_types::Timestamp>,
    /// Time when the valid period ends. The timestamp itself is included in
    /// the valid period.
    #[prost(message, optional, tag = "2")]
    pub not_after: ::core::option::Option<::prost_types::Timestamp>,
}
/// Offsets which produce a new `Validity` instance from either a single
/// timestamp or an existing `Validity` instance.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ValidityOffset {
    /// Offset that produces `not_before`, perhaps negative.
    #[prost(message, optional, tag = "1")]
    pub not_before_offset: ::core::option::Option<::prost_types::Duration>,
    /// Offset that produces `not_after`, perhaps negative.
    #[prost(message, optional, tag = "2")]
    pub not_after_offset: ::core::option::Option<::prost_types::Duration>,
}
/// Container that can contain any serialized data and a corresponding ID.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[serde(default)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Variant {
    /// Unique payload identifier that also defines how to deserialize the `value`.
    #[prost(bytes = "vec", tag = "1")]
    #[serde(with = "crate::base64data")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// Serialized data.
    #[prost(bytes = "vec", tag = "2")]
    #[serde(with = "crate::base64data")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Contains various digest formats for the same underlying file. Mixing
/// digests from various files is "undefined behavior". There is no distinction
/// between empty and not set, it means the same.
///
/// The wire numbers are the codec IDs in
/// <https://github.com/multiformats/multicodec/blob/master/table.csv>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RawDigest {
    #[prost(bytes = "vec", tag = "16")]
    pub psha2: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "17")]
    pub sha1: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "18")]
    pub sha2_256: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "19")]
    pub sha2_512: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "20")]
    pub sha3_512: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "21")]
    pub sha3_384: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "22")]
    pub sha3_256: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "23")]
    pub sha3_224: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "32")]
    pub sha2_384: ::prost::alloc::vec::Vec<u8>,
}
/// Similar to RawDigest, but contains hex-encoded hashes for the sake of better
/// readability and copy-pastability. The set of all possible RawDigest and the
/// set of all possible HexDigests are in a bijective correspondence, by just
/// hex-encoding or hex-decoding each field separately.
///
/// For example, the field sha2_256 could contain
/// "82aac1adbfe3ada1244c1f54b7c949519e1f048067d0c3b236b7ae048fc7e227".
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HexDigest {
    #[prost(string, tag = "16")]
    pub psha2: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub sha1: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub sha2_256: ::prost::alloc::string::String,
    #[prost(string, tag = "19")]
    pub sha2_512: ::prost::alloc::string::String,
    #[prost(string, tag = "20")]
    pub sha3_512: ::prost::alloc::string::String,
    #[prost(string, tag = "21")]
    pub sha3_384: ::prost::alloc::string::String,
    #[prost(string, tag = "22")]
    pub sha3_256: ::prost::alloc::string::String,
    #[prost(string, tag = "23")]
    pub sha3_224: ::prost::alloc::string::String,
    #[prost(string, tag = "32")]
    pub sha2_384: ::prost::alloc::string::String,
}
