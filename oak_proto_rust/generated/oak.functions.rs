// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InitializeRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub wasm_module: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub constant_response_size: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeResponse {
    #[prost(message, optional, tag = "2")]
    pub evidence: ::core::option::Option<super::attestation::v1::Evidence>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InvokeRequest {
    #[prost(message, optional, tag = "2")]
    pub encrypted_request: ::core::option::Option<super::crypto::v1::EncryptedRequest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InvokeResponse {
    #[prost(message, optional, tag = "2")]
    pub encrypted_response: ::core::option::Option<super::crypto::v1::EncryptedResponse>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LookupDataEntry {
    #[prost(bytes = "bytes", tag = "1")]
    pub key: ::prost::bytes::Bytes,
    #[prost(bytes = "bytes", tag = "2")]
    pub value: ::prost::bytes::Bytes,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupDataChunk {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<LookupDataEntry>,
}
/// If the definition of ExtendNextLookupData changes, the estimation of the size
/// when serialized in the Oak Functions Launcher needs to change, too.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtendNextLookupDataRequest {
    #[prost(oneof = "extend_next_lookup_data_request::Data", tags = "1, 2")]
    pub data: ::core::option::Option<extend_next_lookup_data_request::Data>,
}
/// Nested message and enum types in `ExtendNextLookupDataRequest`.
pub mod extend_next_lookup_data_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "1")]
        Chunk(super::LookupDataChunk),
        /// Experimental: a serialized array of varint-prefixed `LookupDataEntry`
        /// values. See
        /// <https://docs.rs/prost/latest/prost/fn.decode_length_delimiter.html> for
        /// more details; the hope here is that by serializing one entry at a time we
        /// can be more efficient.
        #[prost(bytes, tag = "2")]
        LengthDelimitedEntries(::prost::bytes::Bytes),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExtendNextLookupDataResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FinishNextLookupDataRequest {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FinishNextLookupDataResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AbortNextLookupDataResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Empty {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReserveRequest {
    #[prost(uint64, tag = "1")]
    pub additional_entries: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReserveResponse {}
