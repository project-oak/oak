// This file is @generated by prost-build.
/// Information about the public key that the certificate is issued for.
/// All fields of this message must be set. Otherwise the certificate is
/// considered invalid.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubjectPublicKeyInfo {
    /// Public key that this certificate is issued for.
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// Purpose (key usage) ID that describes what private key (that subject public
    /// key corresponds to) is used for.
    /// It also describes it's parameters such as algorithm and serialization
    /// format.
    #[prost(bytes = "vec", tag = "2")]
    pub purpose_id: ::prost::alloc::vec::Vec<u8>,
}
/// Structure that contains proof (or evidence) that the certificate has been
/// created and signed over recently (for some definition of recent).
/// NIST pulses are used as proof of freshness. Pulses are issued every minute
/// and contain random, unpredictable values. Values and their timestamps
/// can be verified to be authentically from the NIST beacon. Having knowledge of
/// such value (or something derived from it) proves that the message was
/// generated after the pulse. See documentation for NIST fields here:
/// <https://csrc.nist.gov/projects/interoperable-randomness-beacons/beacon-20>
/// <https://csrc.nist.gov/csrc/media/Projects/interoperable-randomness-beacons/documents/certificate/beacon-2.0.xsd>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProofOfFreshness {
    /// NIST pulse index (starting with one) of the chain that a pulse is contained
    /// in.
    #[prost(int64, tag = "1")]
    pub nist_chain_index: i64,
    /// NIST pulse index: a positive integer starting at 1 which identifies the
    /// pulse in the chain.
    #[prost(int64, tag = "2")]
    pub nist_pulse_index: i64,
    /// A 64 byte string with a hash derived from all other values in the pulse.
    /// Crucially, it's impossible to predict the value of this field
    /// in future pulses.
    #[prost(bytes = "vec", tag = "3")]
    pub nist_pulse_output_value: ::prost::alloc::vec::Vec<u8>,
}
/// Payload that is signed by the certificate.
/// All fields of this message must be set. Otherwise the certificate is
/// considered invalid.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CertificatePayload {
    /// Certificate validity period.
    #[prost(message, optional, tag = "1")]
    pub validity: ::core::option::Option<super::super::Validity>,
    /// Public key that this certificate is issued for.
    #[prost(message, optional, tag = "2")]
    pub subject_public_key_info: ::core::option::Option<SubjectPublicKeyInfo>,
    #[prost(message, optional, tag = "3")]
    pub proof_of_freshness: ::core::option::Option<ProofOfFreshness>,
}
/// Information about the signature that signs the certificate.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignatureInfo {
    /// Signature value bytes.
    ///
    /// Signature format is defined by the Tink library (which includes the
    /// algorithm used to create this signature):
    /// <<https://developers.google.com/tink/wire-format#digital_signatures>>
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// Minimalistic certificate proto definition.
///
/// Certificate is created as following:
///
/// 1. For SERIALIZED_CERTIFICATE_PAYLOAD type:
///    * \[`CertificatePayload`\] proto message is serialized and signed using the
///      certificate authority's private key.
///    * This serialized message is stored in the `serialized_payload` field.
///    * The signature is stored in the `signature_info`.
/// 1. For ARBITRARY_USER_DATA type:
///    * Arbitrary bytes are signed using the certificate authority's private
///      key.
///    * The bytes are stored in the `serialized_payload` field.
///    * The signature is stored in the `signature_info`.
///
/// The signature is created using the Tink library:
/// <<https://developers.google.com/tink/digital-signature>>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Certificate {
    /// Payload that is signed over.
    #[prost(bytes = "vec", tag = "1")]
    pub serialized_payload: ::prost::alloc::vec::Vec<u8>,
    /// Signature over serialized_payload.
    #[prost(message, optional, tag = "2")]
    pub signature_info: ::core::option::Option<SignatureInfo>,
    /// Format type for the serialized payload.
    #[prost(enumeration = "SerializedPayloadType", tag = "3")]
    pub serialized_payload_type: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SerializedPayloadType {
    PayloadTypeUnspecified = 0,
    /// Serialized \[`CertificatePayload`\] proto.
    PayloadTypeSerializedCertificate = 1,
    /// Arbitrary bytes supplied by the caller.
    PayloadTypeArbitraryUserData = 2,
}
impl SerializedPayloadType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PayloadTypeUnspecified => "PAYLOAD_TYPE_UNSPECIFIED",
            Self::PayloadTypeSerializedCertificate => {
                "PAYLOAD_TYPE_SERIALIZED_CERTIFICATE"
            }
            Self::PayloadTypeArbitraryUserData => "PAYLOAD_TYPE_ARBITRARY_USER_DATA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAYLOAD_TYPE_UNSPECIFIED" => Some(Self::PayloadTypeUnspecified),
            "PAYLOAD_TYPE_SERIALIZED_CERTIFICATE" => {
                Some(Self::PayloadTypeSerializedCertificate)
            }
            "PAYLOAD_TYPE_ARBITRARY_USER_DATA" => {
                Some(Self::PayloadTypeArbitraryUserData)
            }
            _ => None,
        }
    }
}
/// Request message encrypted using Hybrid Public Key Encryption (HPKE).
/// <<https://www.rfc-editor.org/rfc/rfc9180.html>>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EncryptedRequest {
    /// Message encrypted with Authenticated Encryption with Associated Data (AEAD)
    /// using the derived session key.
    #[prost(message, optional, tag = "1")]
    pub encrypted_message: ::core::option::Option<AeadEncryptedMessage>,
    /// Ephemeral Diffie-Hellman client public key that is needed to derive a
    /// session key. Only sent in the first message of the secure session.
    #[prost(bytes = "vec", optional, tag = "2")]
    pub serialized_encapsulated_public_key: ::core::option::Option<
        ::prost::alloc::vec::Vec<u8>,
    >,
}
/// Response message encrypted Hybrid Public Key Encryption (HPKE), which uses a
/// response key generated as part of bidirectional encryption.
/// <<https://www.rfc-editor.org/rfc/rfc9180.html#name-bidirectional-encryption>>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EncryptedResponse {
    /// Message encrypted with Authenticated Encryption with Associated Data (AEAD)
    /// using the derived session key.
    #[prost(message, optional, tag = "1")]
    pub encrypted_message: ::core::option::Option<AeadEncryptedMessage>,
}
/// Message encrypted with Authenticated Encryption with Associated Data (AEAD).
/// <<https://datatracker.ietf.org/doc/html/rfc5116>>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AeadEncryptedMessage {
    #[prost(bytes = "vec", tag = "1")]
    pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub associated_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
}
/// Envelope containing session keys required to encrypt/decrypt messages within
/// a secure session. Needed to serialize contexts in order to send them over an
/// RPC.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SessionKeys {
    /// AEAD key for encrypting/decrypting client requests.
    #[prost(bytes = "vec", tag = "1")]
    pub request_key: ::prost::alloc::vec::Vec<u8>,
    /// AEAD key for encrypting/decrypting enclave responses.
    #[prost(bytes = "vec", tag = "4")]
    pub response_key: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Signature {
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
