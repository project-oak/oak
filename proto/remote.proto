//
// Copyright 2020 The Project Oak Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto3";

package oak.remote;

import "google/protobuf/descriptor.proto";
import "oak_abi/proto/label.proto";
import "oak_abi/proto/application.proto";

message AddRemoteRequest {
  // TODO: Why is this needed?
  string remote_uuid = 1;
  // IP address and port number for a remote Runtime. This could be retrieved from the request, but
  // tonic does not fully support that currently.
  string remote_address = 2;
}

message AddRemoteResponse {
  // TODO: Why is this needed?
  string runtime_uuid = 1;
}

// Request matching a call to the `node_create` function in the runtime.
message NodeCreateRequest {
  // Name of the node
  string name = 1;
  // Node configuration
  oak.application.NodeConfiguration node_configuration = 2;
  // Label of the node
  oak.label.Label label = 3;
  // The initial handle is a handle to a channel on the remote runtime
  RemoteHandle initial_handle = 4;
}

message NodeCreateResponse {
  fixed64 remote_node_id = 1;
}

message ChannelReadRequest {
  // Both runtimes must have the node_info about the node requesting the read, although only one runtime actually holds the node. 
  fixed64 node_id = 1;
  // Handle to a channel on the runtime serving this request
  RemoteHandle read_handle = 2;
  // Whether or not to use downgrading privilege when reading from the channel. 
  bool downgrade = 3;
}

message ChannelReadResponse {
  bytes data = 1;
  repeated RemoteHandle handles = 2;
}

message ChannelWriteRequest {
  // Both runtimes must have the node_info about the node requesting the read, although only one runtime actually holds the node. 
  fixed64 node_id = 1;
  RemoteHandle write_handle = 2;
  // Whether or not to use downgrading privilege when writing to the channel. 
  bool downgrade = 3;
  // Bytes content of the message
  bytes data = 4;
  // Handles content of the message. Handles may be on any of the runtimes in the whole system.
  repeated RemoteHandle handles = 5;
}

message ChannelWriteResponse {
  // empty response
}

// Represents a handle, on a potentially remote runtime. 
message RemoteHandle {
  fixed64 raw_handle = 1;
  // In the first step, this can be the ID of a remote runtime.
  string runtime_id = 2;
}

// As seen in https://grpc.io/docs/guides/concepts/.
service RemoteRuntime {
  // Add the given address to the list of remote runtimes. Returns the `runtime_uuid` of the runtime
  // serving the request in the response, so that the caller can as well add the runtime to the list
  // of its remotes.
  rpc AddRemote(AddRemoteRequest) returns (AddRemoteResponse);

  // Request matching a call to the `node_create` function in the runtime. Returns the `node_id` of
  // the newly created node.
  rpc NodeCreate(NodeCreateRequest) returns (NodeCreateResponse);

  // Request matching a call to the `channel_read` function in the runtime. Returns the message
  // (composed of bytes and handles) if read is successful.
  rpc ChannelRead(ChannelReadRequest) returns (ChannelReadResponse);

  // Request matching a call to the `channel_write` function in the runtime.
  rpc ChannelWrite(ChannelWriteRequest) returns (ChannelWriteResponse);
}