//
// Copyright 2023 The Project Oak Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

use crate::proto::oak::verification::v1::{
    transparency_verification_options::RekorEntryVerification::VerificationData,
    TransparencyVerificationOptions,
};
use alloc::vec::Vec;
use oak_remote_attestation::proto::oak::session::v1::{
    AttestationEndorsement, AttestationEvidence, BinaryAttestation,
};

use crate::rekor::{compare_keys, get_rekor_log_entry_body, verify_rekor_log_entry};
use anyhow::Context;
use base64::{prelude::BASE64_STANDARD, Engine as _};
use core::cmp::Ordering;
use oak_transparency_claims::claims::{
    parse_endorsement_statement, validate_endorsement, verify_validity_duration,
};

/// Reference values used by the verifier to appraise the attestation evidence.
/// <https://www.rfc-editor.org/rfc/rfc9334.html#name-reference-values>
pub struct ReferenceValue {
    pub binary_hash: Vec<u8>,
}

/// A trait implementing the functionality of a verifier that appraises the attestation evidence and
/// produces an attestation result.
/// <https://www.rfc-editor.org/rfc/rfc9334.html#name-verifier>
pub trait AttestationVerifier: Clone + Send + Sync {
    /// Verify that the provided evidence was endorsed and contains specified reference values.
    fn verify(
        evidence: &AttestationEvidence,
        endorsement: &AttestationEndorsement,
        reference_value: &ReferenceValue,
    ) -> anyhow::Result<()>;
}

/// An instance of [`AttestationVerifier`] that succeeds iff the provided attestation is empty.
///
/// Useful when no attestation is expected to be generated by the other side of a remotely
/// attested connection.
#[derive(Clone)]
pub struct InsecureAttestationVerifier;

impl AttestationVerifier for InsecureAttestationVerifier {
    fn verify(
        evidence: &AttestationEvidence,
        _endorsement: &AttestationEndorsement,
        _reference_value: &ReferenceValue,
    ) -> anyhow::Result<()> {
        // We check that the attestation report is empty in order to avoid accidentally ignoring a
        // real attestation from the other side, although in principle a more lenient
        // implementation of this struct could be used that always ignores also non-empty
        // attestations.
        if evidence.attestation.is_empty() {
            Ok(())
        } else {
            Err(anyhow::anyhow!(
                "expected empty attestation report, got {:?}",
                evidence.attestation
            ))
        }
    }
}

/// Verifies the transparent release endorsement for a given measurement, using the given
/// verification options to control the extent of the verification. Summary of the verification
/// logic:
///
/// 1. Verifies that the endorsement statement in the given `BinaryAttestation` instance contains a
/// single subject with a digest measured using the given measurement algorithm, equal to
/// `measurement_from_evidence`.
/// 1. If the input `TransparencyVerificationOptions` requires Rekor log verification:
///     1. verifies that the `BinaryAttestation` contains a valid Rekor log entry (see
///        `verify_rekor_log_entry` for details.),
///     1. verifies the Rekor public key in `BinaryAttestation` against the Rekor public key in
///        `TransparencyVerificationOptions`,
///     1. verifies the endorser public key included in the Rekor log entry against the endorser
///        public key in `TransparencyVerificationOptions`.
pub fn verify_transparent_release_endorsement(
    measurement_from_evidence: &[u8],
    measurement_alg: &str,
    binary_attestation: &BinaryAttestation,
    opts: &TransparencyVerificationOptions,
) -> anyhow::Result<()> {
    verify_endorsement_statement(
        &binary_attestation.endorsement_statement,
        measurement_from_evidence,
        measurement_alg,
    )?;

    if let Some(VerificationData(data)) = &opts.rekor_entry_verification {
        let base64_pem_encoded_rekor_public_key = data.base64_pem_encoded_rekor_public_key.clone();
        let base64_pem_encoded_endorser_public_key =
            data.base64_pem_encoded_endorser_public_key.clone();
        let rekor_public_key_bytes =
            BASE64_STANDARD.decode(&base64_pem_encoded_rekor_public_key)?;

        verify_rekor_log_entry(
            &binary_attestation.rekor_log_entry,
            &rekor_public_key_bytes,
            &binary_attestation.endorsement_statement,
        )?;
        verify_rekor_public_key(binary_attestation, &base64_pem_encoded_rekor_public_key)?;
        verify_endorser_public_key(binary_attestation, &base64_pem_encoded_endorser_public_key)?;
    }

    Ok(())
}

/// Parses the given bytes into an endorsement statement and verifies it against the given Reference
/// values.
pub fn verify_endorsement_statement(
    endorsement_bytes: &[u8],
    binary_digest: &[u8],
    measurement_alg: &str,
) -> anyhow::Result<()> {
    let claim = parse_endorsement_statement(endorsement_bytes)?;
    if let Err(err) = validate_endorsement(&claim) {
        anyhow::bail!("validating endorsement: {err:?}");
    }
    verify_validity_duration(&claim)?;
    if claim.subject.len() != 1 {
        anyhow::bail!(
            "expected 1 subject in the endorsement, found {}",
            claim.subject.len()
        );
    }

    let binary_digest = core::str::from_utf8(binary_digest)?;
    match claim.subject[0].digest.get(measurement_alg) {
        Some(found_digest) => {
            if found_digest != binary_digest {
                anyhow::bail!(
                    "unexpected binary {} digest: expected {}, got {}",
                    measurement_alg,
                    binary_digest,
                    found_digest
                )
            }
        }
        None => anyhow::bail!("missing {measurement_alg} digest in the endorsement statement"),
    }

    Ok(())
}

/// Verifies that the rekor public key in the given BinaryAttestation is either the same as the
/// given public key, signed by it, or derived from it.
fn verify_rekor_public_key(
    binary_attestation: &BinaryAttestation,
    base64_pem_encoded_rekor_public_key: &str,
) -> anyhow::Result<()> {
    // TODO(#4231): Currently, we only check that the public keys are the same. Once Rekor starts
    // using rolling keys, the verification logic will have to be updated.

    let public_key_from_server = BASE64_STANDARD
        .decode(&binary_attestation.base64_pem_encoded_rekor_public_key)
        .context("couldn't base64-decode public key bytes from server")?;

    let public_key_from_client = BASE64_STANDARD
        .decode(base64_pem_encoded_rekor_public_key)
        .context("couldn't base64-decode public key bytes from client")?;

    if compare_keys(&public_key_from_server, &public_key_from_client)? != Ordering::Equal {
        anyhow::bail!(
            "Rekor public key verification failed: expected {:?} found {:?}",
            public_key_from_client,
            public_key_from_server,
        )
    }

    Ok(())
}

/// Verifies that the endorser's public key in the Rekor log entry in the given BinaryAttestation is
/// either the same as the given public key, signed by it, or derived from it.
fn verify_endorser_public_key(
    binary_attestation: &BinaryAttestation,
    base64_pem_encoded_endorser_public_key: &str,
) -> anyhow::Result<()> {
    // TODO(#4231): Currently, we only check that the public keys are the same. Should be updated to
    // support verifying rolling keys.

    let body = get_rekor_log_entry_body(&binary_attestation.rekor_log_entry)?;

    let public_key_from_server = BASE64_STANDARD
        .decode(body.spec.signature.public_key.content)
        .context("couldn't base64-decode public key bytes from server")?;

    let public_key_from_client = BASE64_STANDARD
        .decode(base64_pem_encoded_endorser_public_key)
        .context("couldn't base64-decode public key bytes from client")?;

    if compare_keys(&public_key_from_server, &public_key_from_client)? != Ordering::Equal {
        anyhow::bail!(
            "endorser public key verification failed: expected {:?} found {:?}",
            public_key_from_client,
            public_key_from_server,
        )
    }

    Ok(())
}
