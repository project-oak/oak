//
// Copyright 2023 The Project Oak Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

mod proto {
    pub mod oak {
        pub mod attestation {
            pub mod v1 {
                tonic::include_proto!("oak.attestation.v1");
            }
        }
    }
}

use crate::try_parse_phys_addr;
use anyhow::{anyhow, Context};
use ciborium::{from_reader, into_writer, Value};
use coset::{cwt::ClaimName, CborSerializable};
use oak_dice::{
    cert::{generate_eca_certificate, get_claims_set_from_certifcate_bytes, CODE_DIGEST_ID},
    evidence::{Stage0DiceData, PRIVATE_KEY_SIZE, STAGE0_MAGIC},
};
use p256::ecdsa::SigningKey;
use proto::oak::attestation::v1::{
    CertificateAuthority, DiceData, Evidence, LayerEvidence, RootLayerEvidence, TeePlatform,
};
use sha2::{Digest, Sha256};
use std::{
    fs::{read_dir, read_to_string, OpenOptions},
    io::{Read, Seek, Write},
};
use x86_64::PhysAddr;
use zerocopy::{AsBytes, FromZeroes};

/// A key field made up of all zeroes.
const EMPTY_KEY: [u8; PRIVATE_KEY_SIZE] = [0u8; PRIVATE_KEY_SIZE];

/// The actual size used when encoding a Nist P256 private key.
const P256_PRIVATE_KEY_SIZE: usize = 32;

/// The size of the attestation report generated by AMD SEV-SNP.
///
/// See Table 21 in <https://www.amd.com/system/files/TechDocs/56860.pdf>.
const AMD_SEV_SNP_ATTESTATION_REPORT_SIZE: usize = 1184;

/// The expected string representation of the custom type for the reserved memory range that
/// contains the DICE data.
///
/// Since we use a custom type the Linux Kernel does not recognize it. The text is defined in
/// <https://github.com/torvalds/linux/blob/d88520ad73b79e71e3ddf08de335b8520ae41c5c/arch/x86/kernel/e820.c#L1086>.
const EXPECTED_E820_TYPE: &str = "Unknown E820 type";

/// The path for reading the memory map from the sysfs pseudo-filesystem.
const MEMMAP_PATH: &str = "/sys/firmware/memmap";

/// The path for reading the physical memory from the mem device.
const PHYS_MEM_PATH: &str = "/dev/mem";

/// Builds the DICE evidence and certificate authority for the next DICE layer.
pub struct DiceDataBuilder {
    evidence: Evidence,
    signing_key: SigningKey,
    system_image_measurement: Vec<u8>,
}

impl DiceDataBuilder {
    fn new(evidence: Evidence, signing_key: SigningKey) -> Self {
        DiceDataBuilder {
            evidence,
            signing_key,
            system_image_measurement: Vec::new(),
        }
    }

    /// Measures the downloaded system image bytes.
    pub fn measure_system_image(&mut self, system_image_bytes: &[u8]) -> anyhow::Result<()> {
        if !self.system_image_measurement.is_empty() {
            anyhow::bail!("system image already measured");
        }
        let mut digest = Sha256::default();
        digest.update(system_image_bytes);
        let digest = digest.finalize();
        self.system_image_measurement.extend_from_slice(&digest[..]);
        Ok(())
    }

    /// Generates the DICE data for the next layer.
    pub fn build(self) -> anyhow::Result<DiceData> {
        // We expect that the only entry in the layer evidence contains the certificate for the
        // signing key we received from the previous stage. Since we generated it we are sure there
        // will be exactly one entry.
        let claims_set = get_claims_set_from_certifcate_bytes(
            &self
                .evidence
                .layer_evidence
                .first()
                .unwrap()
                .eca_certificate,
        )
        .context("couldn't get claims set")?;
        // The issuer for the next layer is the subject of the current layer.
        let issuer_id = claims_set
            .subject
            .ok_or_else(|| anyhow!("no subject in certificate"))?;

        let mut evidence = self.evidence;

        let additional_claims = vec![(
            ClaimName::PrivateUse(CODE_DIGEST_ID),
            Value::Bytes(self.system_image_measurement),
        )];

        let (eca_certificate, signing_key) =
            generate_eca_certificate(&self.signing_key, issuer_id, additional_claims)
                .context("couldn't generate ECA certificate for the system image")?;

        evidence.layer_evidence.push(LayerEvidence {
            layer_name: "System Image".to_owned(),
            eca_certificate: eca_certificate.to_vec()?,
        });

        Ok(DiceData {
            evidence: Some(evidence),
            certificate_authority: Some(CertificateAuthority {
                eca_private_key: signing_key.to_bytes().as_slice().into(),
            }),
        })
    }
}

#[derive(Debug)]
struct MemoryRange {
    start: PhysAddr,
    end: PhysAddr,
    type_description: String,
}

/// Extracts the DICE evidence and ECA key from the Stage 0 DICE data located at the given physical
/// address.
///
/// Also zeroes out the original copy of the signing key.
pub fn extract_stage0_evidence_and_key(start: PhysAddr) -> anyhow::Result<DiceDataBuilder> {
    let mut dice_data = read_stage0_dice_data(start)?;
    let result = DiceDataBuilder::new(
        dice_data_to_proto(&dice_data)?,
        SigningKey::from_slice(
            &dice_data.layer_1_certificate_authority.eca_private_key[..P256_PRIVATE_KEY_SIZE],
        )?,
    );

    // Clear the private key bytes.
    dice_data
        .layer_1_certificate_authority
        .eca_private_key
        .copy_from_slice(&EMPTY_KEY);

    Ok(result)
}

/// Reads the DICE data from the physical memory range starting at the given address.
///
/// Zeroes out the source physical memory after copying it.
fn read_stage0_dice_data(start: PhysAddr) -> anyhow::Result<Stage0DiceData> {
    let mut result = Stage0DiceData::new_zeroed();
    let buffer = result.as_bytes_mut();
    // Linux presents an inclusive end address.
    let end = start + (buffer.len() as u64 - 1);
    // Ensure that the exact memory range is marked as reserved.
    if !read_memory_ranges()?.iter().any(|range| {
        range.start == start && range.end == end && range.type_description == EXPECTED_E820_TYPE
    }) {
        anyhow::bail!("DICE data range is not reserved");
    }

    // Read the DICE data from physical memory.
    let mut dice_reader = OpenOptions::new()
        .read(true)
        .open(PHYS_MEM_PATH)
        .context("couldn't open DICE memory device for reading")?;
    dice_reader
        .seek(std::io::SeekFrom::Start(start.as_u64()))
        .context("couldn't seek to DICE offset")?;
    dice_reader
        .read_exact(buffer)
        .context("couldn't read DICE data")?;

    if result.magic != STAGE0_MAGIC {
        anyhow::bail!("invalid DICE data");
    }

    // Clear the physical memory.
    let mut dice_clear = OpenOptions::new()
        .write(true)
        .open(PHYS_MEM_PATH)
        .context("couldn't open DICE memory device for writing")?;
    dice_clear
        .seek(std::io::SeekFrom::Start(start.as_u64()))
        .context("couldn't seek to DICE offset")?;
    dice_clear.write_all(&vec![0u8; result.as_bytes().len()])?;

    Ok(result)
}

/// Reads the memory ranges which supplied by the firmware to the Linux kernel.
fn read_memory_ranges() -> anyhow::Result<Vec<MemoryRange>> {
    read_dir(MEMMAP_PATH)
        .context("memory map not found")?
        .map(|entry| {
            let path = entry?.path();
            let start = try_parse_phys_addr(read_to_string(path.join("start"))?.trim())
                .context("couldn't parse start")?;
            let end = try_parse_phys_addr(read_to_string(path.join("end"))?.trim())
                .context("couldn't parse end")?;
            let type_description = read_to_string(path.join("type"))?.trim().to_string();
            Ok(MemoryRange {
                start,
                end,
                type_description,
            })
        })
        .try_collect()
}

/// Converts the DICE evidence received from Stage 0 to a protocol buffer representation.
fn dice_data_to_proto(dice_data: &Stage0DiceData) -> anyhow::Result<Evidence> {
    let (platform, remote_attestation_report) =
        if dice_data.root_layer_evidence.tee_platform == TeePlatform::AmdSevSnp as u64 {
            (
                TeePlatform::AmdSevSnp as u64,
                dice_data.root_layer_evidence.remote_attestation_report
                    [..AMD_SEV_SNP_ATTESTATION_REPORT_SIZE]
                    .to_vec(),
            )
        } else {
            (TeePlatform::Unspecified as u64, Vec::new())
        };
    let platform = platform.try_into()?;
    let eca_public_key =
        cbor_encoded_bytes_to_vec(&dice_data.root_layer_evidence.eca_public_key[..])?;
    let root_layer_evidence = Some(RootLayerEvidence {
        platform,
        remote_attestation_report,
        eca_public_key,
    });
    let mut layer_evidence = Vec::new();
    let layer_name = "Stage1".to_owned();
    let eca_certificate =
        cbor_encoded_bytes_to_vec(&dice_data.layer_1_evidence.eca_certificate[..])?;
    layer_evidence.push(LayerEvidence {
        layer_name,
        eca_certificate,
    });
    let application_keys = None;
    Ok(Evidence {
        root_layer_evidence,
        layer_evidence,
        application_keys,
    })
}

/// Extracts the bytes used to encode a CBOR object from a slice that might include unused bytes by
/// deserializing and re-serializing the encoded CBOR object.
fn cbor_encoded_bytes_to_vec(bytes: &[u8]) -> anyhow::Result<Vec<u8>> {
    let mut result = Vec::new();
    let value: Value = from_reader(bytes)?;
    into_writer(&value, &mut result)?;
    Ok(result)
}
