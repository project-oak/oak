//
// Copyright 2026 The Project Oak Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

//! HashMap benchmark.
//!
//! Measures HashMap performance in two modes:
//!
//! - **Insert**: Inserts key-value pairs into an empty map. Each insert
//!   allocates a new `Vec<u8>` value, so this stresses the allocator alongside
//!   hashing and memory writes. Comparing enclave vs. Linux reveals allocator
//!   overhead in the TEE.
//!
//! - **Lookup**: Queries keys in a pre-populated map (read-only). No allocation
//!   occurs during measurement, isolating hash + memory-read cost. Comparing
//!   Insert vs. Lookup on the same platform isolates the allocator's
//!   contribution to total overhead.
//!
//! Uses `hashbrown::HashMap` for no_std compatibility (the enclave has
//! no access to `std::collections::HashMap`).

use alloc::vec::Vec;

use hashbrown::HashMap;

use super::MemoryBenchmark;
use crate::{BenchmarkError, BenchmarkResult, LCG_MULTIPLIER, timer::BenchmarkTimer};

/// Default value size (64 bytes).
pub const DEFAULT_VALUE_SIZE: usize = 64;

/// Maximum value size (4 KB).
pub const MAX_VALUE_SIZE: usize = 4096;

/// HashMap operation mode.
#[derive(Debug, Clone, Copy)]
pub enum HashMapMode {
    /// Insert new keys. Stresses the allocator because each insert
    /// allocates a fresh value vector.
    Insert,
    /// Lookup existing keys. Read-only â€” no allocation during measurement.
    Lookup,
}

/// HashMap benchmark.
///
/// Measures the combined cost of hashing, memory access, and (in Insert
/// mode) allocation. Keys are random `u64`s generated by LCG; values are
/// 64-byte vectors by default.
pub struct HashMapBenchmark {
    /// The HashMap being benchmarked.
    map: HashMap<u64, Vec<u8>>,
    /// Pre-generated keys for operations.
    keys: Vec<u64>,
    /// Value template (reused for inserts).
    value_template: Vec<u8>,
    /// Approximate working set size.
    working_set_bytes: usize,
}

impl HashMapBenchmark {
    /// Create a new HashMap benchmark.
    ///
    /// # Arguments
    /// * `num_entries` - Number of entries for pre-population (Lookup) or
    ///   maximum inserts (Insert).
    /// * `value_size` - Size of each value in bytes.
    /// * `seed` - Random seed for key generation.
    pub fn new(num_entries: u32, value_size: usize, seed: u64) -> Self {
        let value_size = value_size.min(MAX_VALUE_SIZE);
        let num_entries = num_entries as usize;

        // Generate keys using LCG.
        let mut keys = Vec::with_capacity(num_entries);
        let mut rng_state = seed;
        for _ in 0..num_entries {
            rng_state = rng_state.wrapping_mul(LCG_MULTIPLIER).wrapping_add(1);
            keys.push(rng_state);
        }

        // Create value template.
        let mut value_template = alloc::vec![0u8; value_size];
        for (i, byte) in value_template.iter_mut().enumerate() {
            *byte = (i & 0xFF) as u8;
        }

        let working_set_bytes = num_entries * (8 + value_size); // key + value

        Self { map: HashMap::with_capacity(num_entries), keys, value_template, working_set_bytes }
    }

    /// Create with default value size (64 bytes).
    pub fn with_defaults(num_entries: u32, seed: u64) -> Self {
        Self::new(num_entries, DEFAULT_VALUE_SIZE, seed)
    }

    /// Pre-populate the map for lookup benchmarks.
    pub fn populate(&mut self) {
        for &key in &self.keys {
            self.map.insert(key, self.value_template.clone());
        }
    }

    /// Clear the map (used to reset between insert benchmark runs).
    pub fn map_clear(&mut self) {
        self.map.clear();
    }

    /// Run the benchmark with a specific mode and timer type.
    pub fn run<T: BenchmarkTimer>(
        &mut self,
        mode: HashMapMode,
        iterations: u32,
        warmup_iterations: u32,
    ) -> Result<BenchmarkResult, BenchmarkError> {
        let total_iterations = (warmup_iterations + iterations) as usize;
        if total_iterations > self.keys.len() {
            return Err(BenchmarkError::InvalidParameter);
        }

        match mode {
            HashMapMode::Insert => self.run_insert::<T>(iterations, warmup_iterations),
            HashMapMode::Lookup => self.run_lookup::<T>(iterations, warmup_iterations),
        }
    }

    fn run_insert<T: BenchmarkTimer>(
        &mut self,
        iterations: u32,
        warmup_iterations: u32,
    ) -> Result<BenchmarkResult, BenchmarkError> {
        // Warmup phase: insert and then clear.
        for i in 0..warmup_iterations as usize {
            let key = self.keys[i];
            self.map.insert(key, self.value_template.clone());
        }
        self.map.clear(); // Reset for measurement.

        // Measurement phase.
        let timer = T::start();

        for i in 0..iterations as usize {
            let key = self.keys[i];
            self.map.insert(key, self.value_template.clone());
            core::hint::black_box(&self.map);
        }

        let timing = timer.stop();
        let bytes_processed = iterations as u64 * (8 + self.value_template.len() as u64);

        Ok(BenchmarkResult::new(timing, iterations, bytes_processed))
    }

    fn run_lookup<T: BenchmarkTimer>(
        &self,
        iterations: u32,
        warmup_iterations: u32,
    ) -> Result<BenchmarkResult, BenchmarkError> {
        let total_iterations = (warmup_iterations + iterations) as usize;

        // Warmup phase.
        for i in 0..warmup_iterations as usize {
            let key = self.keys[i % self.keys.len()];
            let value = self.map.get(&key);
            core::hint::black_box(&value);
        }

        // Measurement phase.
        let timer = T::start();

        for i in warmup_iterations as usize..total_iterations {
            let key = self.keys[i % self.keys.len()];
            let value = self.map.get(&key);
            core::hint::black_box(&value);
        }

        let timing = timer.stop();
        let bytes_processed = iterations as u64 * (8 + self.value_template.len() as u64);

        Ok(BenchmarkResult::new(timing, iterations, bytes_processed))
    }
}

impl MemoryBenchmark for HashMapBenchmark {
    fn working_set_size(&self) -> usize {
        self.working_set_bytes
    }
}
