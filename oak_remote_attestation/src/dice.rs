//
// Copyright 2023 The Project Oak Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

use crate::proto::oak::attestation::v1::{
    CertificateAuthority, DiceData, Evidence, LayerEvidence, RootLayerEvidence, TeePlatform,
};
use alloc::vec::Vec;
use anyhow::{anyhow, Context};
use ciborium::{from_reader, into_writer, Value};
use coset::{
    cwt::{ClaimName, ClaimsSet},
    CborSerializable,
};
use oak_dice::{
    cert::{generate_eca_certificate, get_claims_set_from_certificate_bytes},
    evidence::Stage0DiceData,
};
use p256::ecdsa::SigningKey;

/// The actual size used when encoding a Nist P256 private key.
const P256_PRIVATE_KEY_SIZE: usize = 32;

/// The size of the attestation report generated by AMD SEV-SNP.
///
/// See Table 21 in <https://www.amd.com/system/files/TechDocs/56860.pdf>.
const AMD_SEV_SNP_ATTESTATION_REPORT_SIZE: usize = 1184;

/// Builds the DICE evidence and certificate authority for the next DICE layer.
pub struct DiceBuilder {
    evidence: Evidence,
    signing_key: SigningKey,
}

impl DiceBuilder {
    /// Adds an additional layer of evidence to the DICE data.
    ///
    /// The evidence is in the form of a CWT certificate that contains the `additional_claims`
    /// provided. Adding a layer generates a new ECA private key for the layer and uses it to
    /// replace the existing signing key. The CWT certificate contains the public key for this new
    /// signing key.
    pub fn add_layer(&mut self, additional_claims: Vec<(ClaimName, Value)>) -> anyhow::Result<()> {
        // The last evidence layer contains the certificate for the current signing key. Since the
        // builder contains an existing signing key there must be at least one layer of evidence
        // that contains the certificate.
        let claims_set = self
            .evidence
            .layers
            .last()
            .ok_or_else(|| anyhow::anyhow!("no evidence layers found"))?
            .get_claims()
            .context("couldn't get layer claims set")?;
        // The issuer for the next layer is the subject of the current last layer.
        let issuer_id = claims_set
            .subject
            .ok_or_else(|| anyhow!("no subject in certificate"))?;

        let evidence = &mut self.evidence;
        let (eca_certificate, signing_key) =
            generate_eca_certificate(&self.signing_key, issuer_id, additional_claims)
                .map_err(anyhow::Error::msg)
                .context("couldn't generate ECA certificate for the next layer")?;
        evidence.layers.push(LayerEvidence {
            eca_certificate: eca_certificate.to_vec().map_err(anyhow::Error::msg)?,
        });
        // Replacing the signing key will cause the previous signing key to be dropped, which will
        // zero out its memory.
        self.signing_key = signing_key;
        Ok(())
    }
}

impl Drop for DiceData {
    fn drop(&mut self) {
        // Zero out the ECA private key if it was set.
        if let Some(certificate_authority) = &mut self.certificate_authority {
            certificate_authority.eca_private_key.fill(0);
        }
    }
}

impl From<DiceBuilder> for DiceData {
    fn from(value: DiceBuilder) -> Self {
        DiceData {
            evidence: Some(value.evidence),
            certificate_authority: Some(CertificateAuthority {
                eca_private_key: value.signing_key.to_bytes().as_slice().into(),
            }),
        }
    }
}

impl TryFrom<DiceData> for DiceBuilder {
    type Error = anyhow::Error;
    fn try_from(value: DiceData) -> anyhow::Result<Self> {
        let evidence = value
            .evidence
            .as_ref()
            .ok_or_else(|| anyhow::anyhow!("no evidence"))?;
        let eca_private_key = &value
            .certificate_authority
            .as_ref()
            .ok_or_else(|| anyhow::anyhow!("no certificate authority"))?
            .eca_private_key;
        let signing_key = SigningKey::from_slice(eca_private_key).map_err(anyhow::Error::msg)?;

        Ok(DiceBuilder {
            evidence: evidence.clone(),
            signing_key: signing_key.clone(),
        })
    }
}

impl TryFrom<Stage0DiceData> for DiceData {
    type Error = anyhow::Error;
    fn try_from(value: Stage0DiceData) -> anyhow::Result<Self> {
        let (platform, remote_attestation_report) =
            if value.root_layer_evidence.tee_platform == TeePlatform::AmdSevSnp as u64 {
                (
                    TeePlatform::AmdSevSnp as u64,
                    value.root_layer_evidence.remote_attestation_report
                        [..AMD_SEV_SNP_ATTESTATION_REPORT_SIZE]
                        .to_vec(),
                )
            } else {
                (TeePlatform::Unspecified as u64, Vec::new())
            };
        let platform = platform.try_into().map_err(anyhow::Error::msg)?;
        let eca_public_key =
            cbor_encoded_bytes_to_vec(&value.root_layer_evidence.eca_public_key[..])?;
        let root_layer = Some(RootLayerEvidence {
            platform,
            remote_attestation_report,
            eca_public_key,
        });
        let mut layers = Vec::new();
        let eca_certificate =
            cbor_encoded_bytes_to_vec(&value.layer_1_evidence.eca_certificate[..])?;
        layers.push(LayerEvidence { eca_certificate });
        let application_keys = None;
        let evidence = Some(Evidence {
            root_layer,
            layers,
            application_keys,
        });
        let certificate_authority = Some(CertificateAuthority {
            eca_private_key: value.layer_1_certificate_authority.eca_private_key
                [..P256_PRIVATE_KEY_SIZE]
                .to_vec(),
        });

        Ok(DiceData {
            evidence,
            certificate_authority,
        })
    }
}

impl LayerEvidence {
    /// Extracts the `ClaimsSet` encoded in the ECA certificate of the layer.
    pub fn get_claims(&self) -> anyhow::Result<ClaimsSet> {
        get_claims_set_from_certificate_bytes(&self.eca_certificate).map_err(anyhow::Error::msg)
    }
}

/// Extracts the bytes used to encode a CBOR object from a slice that might include unused bytes by
/// deserializing and re-serializing the encoded CBOR object.
fn cbor_encoded_bytes_to_vec(bytes: &[u8]) -> anyhow::Result<Vec<u8>> {
    let mut result = Vec::new();
    let value: Value = from_reader(bytes).map_err(anyhow::Error::msg)?;
    into_writer(&value, &mut result).map_err(anyhow::Error::msg)?;
    Ok(result)
}
