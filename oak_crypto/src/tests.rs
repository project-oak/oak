//
// Copyright 2023 The Project Oak Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

use crate::{
    aead::{AEAD_ALGORITHM_KEY_SIZE_BYTES, AEAD_NONCE_SIZE_BYTES},
    hpke::{setup_base_recipient, setup_base_sender, KeyPair},
    util::i2osp,
    RecipientCryptoProvider, SenderCryptoProvider,
};

/// Test AES-GCM key that is only used in tests.
/// Was generated by calling [`Hpke::setup_base_sender`].
const TEST_AEAD_KEY: [u8; AEAD_ALGORITHM_KEY_SIZE_BYTES] = [
    11, 107, 5, 176, 4, 145, 171, 193, 163, 81, 105, 238, 171, 115, 56, 160, 130, 85, 22, 227, 118,
    76, 77, 89, 144, 223, 10, 112, 11, 149, 205, 199,
];
/// Test AES-GCM nonce that is only used in tests.
const TEST_NONCE: [u8; AEAD_NONCE_SIZE_BYTES] = [
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
];
const TEST_HPKE_INFO: &[u8] = b"Test HPKE info";
const TEST_REQUEST_MESSAGE: &[u8] = b"Test request message";
const TEST_REQUEST_ASSOCIATED_DATA: &[u8] = b"Test request associated data";
const TEST_RESPONSE_MESSAGE: &[u8] = b"Test response message";
const TEST_RESPONSE_ASSOCIATED_DATA: &[u8] = b"Test response associated data";
// Number of message exchanges done to test secure session handling.
const TEST_SESSION_SIZE: usize = 8;

#[test]
fn test_aead() {
    let encrypted_message = crate::aead::encrypt(
        &TEST_AEAD_KEY,
        &TEST_NONCE,
        TEST_REQUEST_MESSAGE,
        TEST_REQUEST_ASSOCIATED_DATA,
    )
    .expect("couldn't encrypt test message");
    // Check that the message was encrypted.
    assert_ne!(TEST_REQUEST_MESSAGE, encrypted_message);
    let decrypted_message = crate::aead::decrypt(
        &TEST_AEAD_KEY,
        &TEST_NONCE,
        &encrypted_message,
        TEST_REQUEST_ASSOCIATED_DATA,
    )
    .expect("couldn't decrypt test message");
    // Test that AEAD decrypts message to the original one.
    assert_eq!(TEST_REQUEST_MESSAGE, decrypted_message);
}

#[test]
fn test_hpke() {
    let recipient_key_pair = KeyPair::generate();
    let (serialized_encapsulated_public_key, mut sender_context, mut sender_response_context) =
        setup_base_sender(
            &recipient_key_pair.get_serialized_public_key(),
            TEST_HPKE_INFO,
        )
        .expect("couldn't setup base sender");
    let (mut recipient_context, mut recipient_response_context) = setup_base_recipient(
        &serialized_encapsulated_public_key,
        &recipient_key_pair,
        TEST_HPKE_INFO,
    )
    .expect("couldn't setup base recipient");

    for i in 0..TEST_SESSION_SIZE {
        let test_request_message = [TEST_REQUEST_MESSAGE, &[i as u8]].concat();
        let test_request_associated_data = [TEST_REQUEST_ASSOCIATED_DATA, &[i as u8]].concat();
        let test_response_message = [TEST_RESPONSE_MESSAGE, &[i as u8]].concat();
        let test_response_associated_data = [TEST_RESPONSE_ASSOCIATED_DATA, &[i as u8]].concat();

        let encrypted_request = sender_context
            .seal(&test_request_message, &test_request_associated_data)
            .expect("sender context couldn't seal request");
        // Check that the message was encrypted.
        assert_ne!(test_request_message, encrypted_request);
        let decrypted_request = recipient_context
            .open(&encrypted_request, &test_request_associated_data)
            .expect("recipient context couldn't open request");
        assert_eq!(test_request_message, decrypted_request);

        let encrypted_response = recipient_response_context
            .seal(&test_response_message, &test_response_associated_data)
            .expect("recipient context couldn't seal response");
        // Check that the message was encrypted.
        assert_ne!(test_response_message, encrypted_response);
        let decrypted_response = sender_response_context
            .open(&encrypted_response, &test_response_associated_data)
            .expect("sender couldn't open response");
        assert_eq!(test_response_message, decrypted_response);
    }
}

#[test]
fn test_crypto_provider() {
    let recipient_crypto_provider = RecipientCryptoProvider::new();
    let serialized_recipient_public_key = recipient_crypto_provider.get_serialized_public_key();
    let sender_crypto_provider = SenderCryptoProvider::new(&serialized_recipient_public_key);

    let (serialized_ephemeral_public_key, mut sender_request_encryptor) = sender_crypto_provider
        .create_encryptor()
        .expect("couldn't create sender request encryptor");
    let mut recipient_request_decryptor = recipient_crypto_provider
        .create_decryptor(&serialized_ephemeral_public_key)
        .expect("couldn't create recipient request decryptor");

    for i in 0..TEST_SESSION_SIZE {
        let test_request_message = [TEST_REQUEST_MESSAGE, &[i as u8]].concat();
        let test_request_associated_data = [TEST_REQUEST_ASSOCIATED_DATA, &[i as u8]].concat();
        let test_response_message = [TEST_RESPONSE_MESSAGE, &[i as u8]].concat();
        let test_response_associated_data = [TEST_RESPONSE_ASSOCIATED_DATA, &[i as u8]].concat();

        let (encrypted_request, sender_response_decryptor) = sender_request_encryptor
            .encrypt(&test_request_message, &test_request_associated_data)
            .expect("sender couldn't encrypt request");
        // Check that the message was encrypted.
        assert_ne!(test_request_message, encrypted_request);
        let (decrypted_request, recipient_response_encryptor) = recipient_request_decryptor
            .decrypt(&encrypted_request, &test_request_associated_data)
            .expect("recipient couldn't decrypt request");
        assert_eq!(test_request_message, decrypted_request);

        let (encrypted_response, new_recipient_request_decryptor) = recipient_response_encryptor
            .encrypt(&test_response_message, &test_response_associated_data)
            .expect("recipient couldn't encrypt response");
        // Check that the message was encrypted.
        assert_ne!(test_response_message, encrypted_response);
        let (decrypted_response, new_sender_request_encryptor) = sender_response_decryptor
            .decrypt(&encrypted_response, &test_response_associated_data)
            .expect("sender couldn't decrypt response");
        assert_eq!(test_response_message, decrypted_response);

        sender_request_encryptor = new_sender_request_encryptor;
        recipient_request_decryptor = new_recipient_request_decryptor;
    }
}

#[test]
fn test_i2osp() {
    assert_eq!(i2osp::<4>(0x1000).unwrap(), [0x00, 0x00, 0x10, 0x00]);
    assert_eq!(i2osp::<4>(0x123).unwrap(), [0x00, 0x00, 0x01, 0x23]);
    assert_eq!(i2osp::<3>(0x12345).unwrap(), [0x01, 0x23, 0x45]);
    assert!(i2osp::<1>(0x123).is_err());
}
