//
// Copyright 2023 The Project Oak Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

//! Implementation of the Bidirectional Hybrid Public Key Encryption (HPKE) scheme from RFC9180.
//! <https://www.rfc-editor.org/rfc/rfc9180.html>
//! <https://www.rfc-editor.org/rfc/rfc9180.html#name-bidirectional-encryption>

use crate::{
    hpke::{
        setup_base_recipient, setup_base_sender, KeyPair, RecipientRequestContext,
        RecipientResponseContext, SenderRequestContext, SenderResponseContext,
    },
    schema::{AeadEncryptedMessage, EncryptedRequest, EncryptedResponse},
};
use alloc::{boxed::Box, sync::Arc, vec::Vec};
use anyhow::{anyhow, Context};

// TODO(#3642): Remove this key and use a real encapsulated key generated by the client once Java
// encryption is implemented.
pub(crate) const TEST_ENCAPSULATED_PUBLIC_KEY: [u8; 65] = [
    4, 61, 141, 127, 160, 162, 184, 158, 72, 237, 105, 64, 182, 118, 163, 183, 174, 1, 81, 66, 139,
    37, 218, 208, 17, 139, 159, 158, 68, 123, 124, 96, 114, 150, 38, 251, 112, 28, 121, 132, 45,
    250, 118, 208, 142, 153, 124, 192, 139, 178, 239, 188, 177, 219, 52, 178, 123, 117, 254, 171,
    248, 77, 4, 242, 118,
];

/// Info string used by Hybrid Public Key Encryption;
pub(crate) const OAK_HPKE_INFO: &[u8] = b"Oak Hybrid Public Key Encryption v1";

pub trait CryptoContextGenerator {
    fn generate_context(&self) -> anyhow::Result<CryptoContext>;
}

// TODO(#3841): Implement Oak Kernel Crypto API and return corresponding session keys instead.
pub struct CryptoContext {
    pub(crate) recipient_request_context: RecipientRequestContext,
    pub(crate) recipient_response_context: RecipientResponseContext,
}

pub struct EncryptionKeyProvider {
    key_pair: KeyPair,
}

impl Default for EncryptionKeyProvider {
    fn default() -> Self {
        Self::new()
    }
}

impl EncryptionKeyProvider {
    /// Creates a crypto provider with a newly generated key pair.
    pub fn new() -> Self {
        Self {
            key_pair: KeyPair::generate(),
        }
    }

    /// Returns a NIST P-256 SEC1 encoded point public key.
    /// <https://secg.org/sec1-v2.pdf>
    pub fn get_serialized_public_key(&self) -> Vec<u8> {
        self.key_pair.get_serialized_public_key()
    }
}

impl CryptoContextGenerator for EncryptionKeyProvider {
    fn generate_context(&self) -> anyhow::Result<CryptoContext> {
        let (recipient_request_context, recipient_response_context) =
            setup_base_recipient(&TEST_ENCAPSULATED_PUBLIC_KEY, &self.key_pair, OAK_HPKE_INFO)
                .context("couldn't generate recipient crypto context")?;
        Ok(CryptoContext {
            recipient_request_context,
            recipient_response_context,
        })
    }
}

/// Encryptor object for encrypting sender requests that will be sent to the recipient and
/// decrypting recipient responses that are received by the sender. Each Encryptor object
/// corresponds to a single crypto session between the sender and the recipient.
///
/// Sequence numbers for requests and responses are incremented separately, meaning that there could
/// be multiple responses per request and multiple requests per response.
pub struct SenderEncryptor {
    /// Encapsulated public key needed to establish a symmetric session key.
    /// Only sent in the initial request message of the session.
    serialized_encapsulated_public_key: Option<Vec<u8>>,
    sender_request_context: SenderRequestContext,
    sender_response_context: SenderResponseContext,
}

impl SenderEncryptor {
    /// Creates an HPKE crypto context by generating an new ephemeral key pair.
    /// The `serialized_recipient_public_key` must be a NIST P-256 SEC1 encoded point public key.
    /// <https://secg.org/sec1-v2.pdf>
    pub fn create(serialized_recipient_public_key: &[u8]) -> anyhow::Result<Self> {
        let (serialized_encapsulated_public_key, sender_request_context, sender_response_context) =
            setup_base_sender(serialized_recipient_public_key, OAK_HPKE_INFO)
                .context("couldn't create sender crypto context")?;
        Ok(Self {
            serialized_encapsulated_public_key: Some(serialized_encapsulated_public_key.to_vec()),
            sender_request_context,
            sender_response_context,
        })
    }

    /// Encrypts `plaintext` and authenticates `associated_data` using AEAD.
    /// Returns a [`EncryptedRequest`] proto message.
    /// <https://datatracker.ietf.org/doc/html/rfc5116>
    pub fn encrypt(
        &mut self,
        plaintext: &[u8],
        associated_data: &[u8],
    ) -> anyhow::Result<EncryptedRequest> {
        let ciphertext = self
            .sender_request_context
            .seal(plaintext, associated_data)
            .context("couldn't encrypt request")?;
        let request = EncryptedRequest {
            encrypted_message: Some(AeadEncryptedMessage {
                ciphertext,
                associated_data: associated_data.to_vec(),
            }),
            /// Encapsulated public key is only sent in the initial request message of the session.
            serialized_encapsulated_public_key: self.serialized_encapsulated_public_key.take(),
        };
        Ok(request)
    }

    /// Decrypts a [`EncryptedResponse`] proto message using AEAD.
    /// Returns a response message plaintext and associated data.
    /// <https://datatracker.ietf.org/doc/html/rfc5116>
    pub fn decrypt(
        &mut self,
        encrypted_response: &EncryptedResponse,
    ) -> anyhow::Result<(Vec<u8>, Vec<u8>)> {
        let encrypted_message = encrypted_response
            .encrypted_message
            .as_ref()
            .context("response doesn't contain encrypted message")?;
        let plaintext = self
            .sender_response_context
            .open(
                &encrypted_message.ciphertext,
                &encrypted_message.associated_data,
            )
            .context("couldn't decrypt response")?;
        Ok((plaintext, encrypted_message.associated_data.to_vec()))
    }
}

enum RecipientEncryptorState {
    Uninitialized,
    Initialized(Box<RecipientRequestContext>, Box<RecipientResponseContext>),
}

/// Encryptor object for decrypting sender requests that are received by the recipient and
/// encrypting recipient responses that will be sent back to the sender. Each Encryptor object
/// corresponds to a single crypto session between the sender and the recipient.
/// Encryptor state is initialized after receiving an initial request messagecontaining sender's
/// encapsulated public key.
///
/// Sequence numbers for requests and responses are incremented separately, meaning that there could
/// be multiple responses per request and multiple requests per response.
pub struct RecipientEncryptor {
    crypto_context_generator: Arc<dyn CryptoContextGenerator>,
    state: RecipientEncryptorState,
}

impl RecipientEncryptor {
    pub fn new(crypto_context_generator: Arc<dyn CryptoContextGenerator>) -> Self {
        Self {
            crypto_context_generator,
            state: RecipientEncryptorState::Uninitialized,
        }
    }

    /// Decrypts a [`EncryptedRequest`] proto message using AEAD.
    /// Returns a response message plaintext and associated data.
    /// <https://datatracker.ietf.org/doc/html/rfc5116>
    pub fn decrypt(
        &mut self,
        encrypted_request: &EncryptedRequest,
    ) -> anyhow::Result<(Vec<u8>, Vec<u8>)> {
        match &mut self.state {
            RecipientEncryptorState::Uninitialized => {
                let crypto_context = self
                    .crypto_context_generator
                    .generate_context()
                    .context("couldn't generate recipient crypto context")?;
                let (mut recipient_request_context, recipient_response_context) = (
                    crypto_context.recipient_request_context,
                    crypto_context.recipient_response_context,
                );
                let (plaintext, associated_data) =
                    Self::decrypt_with_context(encrypted_request, &mut recipient_request_context)?;
                self.state = RecipientEncryptorState::Initialized(
                    Box::new(recipient_request_context),
                    Box::new(recipient_response_context),
                );
                Ok((plaintext, associated_data))
            }
            RecipientEncryptorState::Initialized(recipient_request_context, _) => {
                Self::decrypt_with_context(encrypted_request, recipient_request_context)
            }
        }
    }

    fn decrypt_with_context(
        encrypted_request: &EncryptedRequest,
        context: &mut RecipientRequestContext,
    ) -> anyhow::Result<(Vec<u8>, Vec<u8>)> {
        let encrypted_message = encrypted_request
            .encrypted_message
            .as_ref()
            .context("request doesn't contain encrypted message")?;
        let plaintext = context
            .open(
                &encrypted_message.ciphertext,
                &encrypted_message.associated_data,
            )
            .context("couldn't decrypt request")?;
        Ok((plaintext, encrypted_message.associated_data.to_vec()))
    }

    /// Encrypts `plaintext` and authenticates `associated_data` using AEAD.
    /// Returns a [`EncryptedResponse`] proto message.
    /// <https://datatracker.ietf.org/doc/html/rfc5116>
    pub fn encrypt(
        &mut self,
        plaintext: &[u8],
        associated_data: &[u8],
    ) -> anyhow::Result<EncryptedResponse> {
        match &mut self.state {
            RecipientEncryptorState::Uninitialized => Err(anyhow!(
                "couldn't encrypt response because recipient crypto context is not initialized"
            )),
            RecipientEncryptorState::Initialized(_, recipient_response_context) => {
                let ciphertext = recipient_response_context
                    .seal(plaintext, associated_data)
                    .context("couldn't encrypt response")?;
                let response = EncryptedResponse {
                    encrypted_message: Some(AeadEncryptedMessage {
                        ciphertext,
                        associated_data: associated_data.to_vec(),
                    }),
                };
                Ok(response)
            }
        }
    }
}
