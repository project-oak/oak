#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupDataRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupDataResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogRequest {
    #[prost(string, tag = "1")]
    pub entry: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogResponse {}
#[derive(Clone)]
pub struct TestServiceServer<S> {
    service: S,
}
impl<S: TestService> ::micro_rpc::Transport for TestServiceServer<S> {
    fn invoke(
        &mut self,
        request_bytes: &[u8],
    ) -> Result<::prost::alloc::vec::Vec<u8>, !> {
        let response: ::micro_rpc::Response = self.invoke_inner(request_bytes).into();
        let response_bytes = response.encode_to_vec();
        Ok(response_bytes)
    }
}
impl<S: TestService> TestServiceServer<S> {
    pub fn new(service: S) -> Self {
        Self { service }
    }
    fn invoke_inner(
        &mut self,
        request_bytes: &[u8],
    ) -> Result<::prost::alloc::vec::Vec<u8>, ::micro_rpc::Status> {
        let request = ::micro_rpc::Request::decode(request_bytes)
            .map_err(|err| {
                ::micro_rpc::Status::new_with_message(
                    ::micro_rpc::StatusCode::Internal,
                    ::micro_rpc::format!(
                        "Client failed to deserialize the response: {:?}", err
                    ),
                )
            })?;
        match request.method_id {
            15 => {
                let request = <LookupDataRequest>::decode(request.body.as_ref())
                    .map_err(|err| {
                        ::micro_rpc::Status::new_with_message(
                            ::micro_rpc::StatusCode::Internal,
                            ::micro_rpc::format!(
                                "Service failed to deserialize the request: {:?}", err
                            ),
                        )
                    })?;
                let response = self.service.lookup_data(request)?;
                let response_body = response.encode_to_vec();
                Ok(response_body)
            }
            16 => {
                let request = <LogRequest>::decode(request.body.as_ref())
                    .map_err(|err| {
                        ::micro_rpc::Status::new_with_message(
                            ::micro_rpc::StatusCode::Internal,
                            ::micro_rpc::format!(
                                "Service failed to deserialize the request: {:?}", err
                            ),
                        )
                    })?;
                let response = self.service.log(request)?;
                let response_body = response.encode_to_vec();
                Ok(response_body)
            }
            17 => {
                let request = <()>::decode(request.body.as_ref())
                    .map_err(|err| {
                        ::micro_rpc::Status::new_with_message(
                            ::micro_rpc::StatusCode::Internal,
                            ::micro_rpc::format!(
                                "Service failed to deserialize the request: {:?}", err
                            ),
                        )
                    })?;
                let response = self.service.empty(request)?;
                let response_body = response.encode_to_vec();
                Ok(response_body)
            }
            18 => {
                let request = <::prost_types::Duration>::decode(request.body.as_ref())
                    .map_err(|err| {
                        ::micro_rpc::Status::new_with_message(
                            ::micro_rpc::StatusCode::Internal,
                            ::micro_rpc::format!(
                                "Service failed to deserialize the request: {:?}", err
                            ),
                        )
                    })?;
                let response = self.service.duration(request)?;
                let response_body = response.encode_to_vec();
                Ok(response_body)
            }
            19 => {
                let request = <::prost_types::Timestamp>::decode(request.body.as_ref())
                    .map_err(|err| {
                        ::micro_rpc::Status::new_with_message(
                            ::micro_rpc::StatusCode::Internal,
                            ::micro_rpc::format!(
                                "Service failed to deserialize the request: {:?}", err
                            ),
                        )
                    })?;
                let response = self.service.timestamp(request)?;
                let response_body = response.encode_to_vec();
                Ok(response_body)
            }
            20 => {
                let request = <::prost_types::Any>::decode(request.body.as_ref())
                    .map_err(|err| {
                        ::micro_rpc::Status::new_with_message(
                            ::micro_rpc::StatusCode::Internal,
                            ::micro_rpc::format!(
                                "Service failed to deserialize the request: {:?}", err
                            ),
                        )
                    })?;
                let response = self.service.any(request)?;
                let response_body = response.encode_to_vec();
                Ok(response_body)
            }
            _ => Err(::micro_rpc::Status::new(::micro_rpc::StatusCode::Unimplemented)),
        }
    }
}
pub trait TestService: Sized {
    fn lookup_data(
        &mut self,
        request: LookupDataRequest,
    ) -> Result<LookupDataResponse, ::micro_rpc::Status>;
    fn log(&mut self, request: LogRequest) -> Result<LogResponse, ::micro_rpc::Status>;
    fn empty(&mut self, request: ()) -> Result<(), ::micro_rpc::Status>;
    fn duration(
        &mut self,
        request: ::prost_types::Duration,
    ) -> Result<::prost_types::Duration, ::micro_rpc::Status>;
    fn timestamp(
        &mut self,
        request: ::prost_types::Timestamp,
    ) -> Result<::prost_types::Timestamp, ::micro_rpc::Status>;
    fn any(
        &mut self,
        request: ::prost_types::Any,
    ) -> Result<::prost_types::Any, ::micro_rpc::Status>;
}
pub struct TestServiceClient<T: ::micro_rpc::Transport> {
    transport: T,
}
impl<T: ::micro_rpc::Transport> TestServiceClient<T> {
    pub fn new(transport: T) -> Self {
        Self { transport }
    }
    pub fn lookup_data(
        &mut self,
        request: &LookupDataRequest,
    ) -> Result<Result<LookupDataResponse, ::micro_rpc::Status>, T::Error> {
        ::micro_rpc::client_invoke(&mut self.transport, 15, request)
    }
    pub fn log(
        &mut self,
        request: &LogRequest,
    ) -> Result<Result<LogResponse, ::micro_rpc::Status>, T::Error> {
        ::micro_rpc::client_invoke(&mut self.transport, 16, request)
    }
    pub fn empty(
        &mut self,
        request: &(),
    ) -> Result<Result<(), ::micro_rpc::Status>, T::Error> {
        ::micro_rpc::client_invoke(&mut self.transport, 17, request)
    }
    pub fn duration(
        &mut self,
        request: &::prost_types::Duration,
    ) -> Result<Result<::prost_types::Duration, ::micro_rpc::Status>, T::Error> {
        ::micro_rpc::client_invoke(&mut self.transport, 18, request)
    }
    pub fn timestamp(
        &mut self,
        request: &::prost_types::Timestamp,
    ) -> Result<Result<::prost_types::Timestamp, ::micro_rpc::Status>, T::Error> {
        ::micro_rpc::client_invoke(&mut self.transport, 19, request)
    }
    pub fn any(
        &mut self,
        request: &::prost_types::Any,
    ) -> Result<Result<::prost_types::Any, ::micro_rpc::Status>, T::Error> {
        ::micro_rpc::client_invoke(&mut self.transport, 20, request)
    }
}
pub struct TestServiceAsyncClient<T: ::micro_rpc::AsyncTransport> {
    transport: T,
}
impl<T: ::micro_rpc::AsyncTransport> TestServiceAsyncClient<T> {
    pub fn new(transport: T) -> Self {
        Self { transport }
    }
    pub async fn lookup_data(
        &mut self,
        request: &LookupDataRequest,
    ) -> Result<Result<LookupDataResponse, ::micro_rpc::Status>, T::Error> {
        ::micro_rpc::async_client_invoke(&mut self.transport, 15, request).await
    }
    pub async fn log(
        &mut self,
        request: &LogRequest,
    ) -> Result<Result<LogResponse, ::micro_rpc::Status>, T::Error> {
        ::micro_rpc::async_client_invoke(&mut self.transport, 16, request).await
    }
    pub async fn empty(
        &mut self,
        request: &(),
    ) -> Result<Result<(), ::micro_rpc::Status>, T::Error> {
        ::micro_rpc::async_client_invoke(&mut self.transport, 17, request).await
    }
    pub async fn duration(
        &mut self,
        request: &::prost_types::Duration,
    ) -> Result<Result<::prost_types::Duration, ::micro_rpc::Status>, T::Error> {
        ::micro_rpc::async_client_invoke(&mut self.transport, 18, request).await
    }
    pub async fn timestamp(
        &mut self,
        request: &::prost_types::Timestamp,
    ) -> Result<Result<::prost_types::Timestamp, ::micro_rpc::Status>, T::Error> {
        ::micro_rpc::async_client_invoke(&mut self.transport, 19, request).await
    }
    pub async fn any(
        &mut self,
        request: &::prost_types::Any,
    ) -> Result<Result<::prost_types::Any, ::micro_rpc::Status>, T::Error> {
        ::micro_rpc::async_client_invoke(&mut self.transport, 20, request).await
    }
}
