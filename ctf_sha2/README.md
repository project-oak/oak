# CTF SHA2: Falsification Challenges

This directory contains binaries and supporting infrastructure designed to pose
a challenge: can you falsify the security claim they make?

This challenge is for software engineers, particularly those with an interest in
security, who want to explore the guarantees and potential pitfalls of Trusted
Execution Environments (TEEs) like Google Cloud's Confidential Space and Oak
Containers.

## The Claim

The core of this challenge is a simple claim, implemented by each variant, each
with a strong claim:

**For any given execution, the binary generates a secret random number,
calculates its SHA2-256 digest, and then creates a cryptographic attestation
that includes the digest. The original secret number is then discarded and is
never revealed outside of the TEE.**

See [Claim 35705](../docs/tr/claim/35705.md) for a formal definition of this
claim.

In essence, the binary proves it generated a secret number (by showing its
digest in the attestation) without ever exposing the number itself.

## The Abstract Challenge

Each variant of this challenge operates on the same abstract principles:

1. **Secret Generation**: The TEE workload generates a secret random number (the
   "flag").
2. **Commitment**: It calculates the SHA2-256 digest of this flag.
3. **Attestation**: It requests an attestation from the TEE infrastructure. This
   attestation includes the flag's digest as a claim (specifically as a nonce or
   data digest).
4. **Secrecy**: The workload discards the flag and ensures (conceptually) that
   it is never leaked outside the trusted environment.

## The Goal: Falsify the Claim

Your mission is to prove that the secrecy claim is false for a given execution.
To win, you must produce:

1. **A valid attestation** generated by the binary, which commits to a specific
   digest.
2. **The secret flag** that matches that digest.

If the system works as intended, this should be impossible because the flag is
never revealed. If you can produce both, you have successfully "falsified" the
claim that the flag remains secret.

### The Arbiter

There is a single "Arbiter" (verifier) program for all challenge variants,
located at `ctf_sha2/arbiter.rs`. This program acts as the judge. It accepts
your proof (the attestation and the flag) and determines if:

- The attestation is valid and authentic.
- The hash of your provided flag matches the hash committed to in the
  attestation.

If both checks pass, the Arbiter declares the claim **Falsified**.

### Input Format

The arbiter expects a binary protobuf file containing an
`oak.ctf_sha2.arbiter.ArbiterInput` message, defined in
`ctf_sha2/proto/arbiter.proto`.

You will need to construct this message yourself. It contains:

1. `flag`: The bytes of the secret flag you recovered.
2. `tee_proof`: A oneof field containing the proof specific to the environment
   (e.g., `confidential_space_jwt` or `attested_signature`).

### Running the Arbiter

You can run the arbiter using Bazel. The command takes two arguments:
`--input-file` and `--output-file-toml`.

```bash
bazel run //ctf_sha2:arbiter -- \
    --input-file=/path/to/your/input.binpb \
    --output-file-toml=/tmp/falsify_result.toml
```

### Interpreting Arbiter Output

The Arbiter for each challenge will write a TOML file with the result. The file
will contain a `status` field with one of the following values:

- `Falsified`: Congratulations! You have successfully falsified the claim. The
  provided flag's SHA2-256 digest matches the hash committed to in the
  attestation.
- `NotFalsified`: The claim holds. The provided flag's digest does not match the
  hash in the attestation, or the attestation verification failed.
- `SetupError`: There was an error reading the input file.

## Variants

This challenge is implemented for different TEE environments. See the respective
directories for specific instructions on deployment, participation, and
verification.

- [**Confidential Space Challenge**](./confidential_space/README.md)
- [**Oak Containers Challenge**](./containers/README.md)
