# Copyright 2025 The Project Oak Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Bazel build definitions for micro RPC."""

load("@rules_rust//cargo:defs.bzl", "cargo_build_script")
load("@rules_rust//rust:defs.bzl", "rust_library")

def _generate_cargo_build_impl(ctx):
    # The build script is run from the package's directory. We need to find the
    # relative path to the workspace root.
    package_path = ctx.label.package
    if package_path:
        path_to_root = "/".join([".."] * len(package_path.split("/")))
    else:
        path_to_root = "."

    proto_paths = []
    for proto_file in ctx.files.protos:
        proto_paths.append(path_to_root + "/" + proto_file.short_path)

    build_rs_content = """
// Generated by micro_rpc_build/build_defs.bzl
fn main() {{
    micro_rpc_build::compile(
        &[
{protos}
        ],
        &oak_proto_build_utils::get_common_proto_path("{path_to_root}"),
        micro_rpc_build::CompileOptions {{
            extern_paths: vec![
{extern_paths}
            ],
            ..Default::default()
        }},
    );
}}
""".format(
        protos = ",\\n".join(["            \"{}\",".format(p) for p in proto_paths]),
        path_to_root = path_to_root,
        extern_paths = ",\\n".join(["                micro_rpc_build::ExternPath::new(\"{}\", \"{}\")".format(k, v) for k, v in ctx.attr.extern_paths.items()]),
    )

    build_rs_file = ctx.actions.declare_file(ctx.attr.name + "_build.rs")
    ctx.actions.write(
        output = build_rs_file,
        content = build_rs_content,
    )

    return [DefaultInfo(files = depset([build_rs_file]))]

_generate_cargo_build = rule(
    implementation = _generate_cargo_build_impl,
    attrs = {
        "protos": attr.label_list(allow_files = True, mandatory = True),
        "extern_paths": attr.string_dict(mandatory = True),
    },
)

def _generate_service_impl(ctx):
    package_parts = ctx.attr.proto_package_name.split(".")

    mod_content = """
pub mod {mod} {{
    use prost::Message;
    include!(concat!(env!("OUT_DIR"), "/{filename}"));
}}
""".format(
        mod = package_parts.pop(),
        filename = ctx.attr.proto_package_name + ".rs",
    )

    for mod in package_parts[::-1]:
        mod_content = """
pub mod {mod} {{
{inner_mod_content}
}}
""".format(
            mod = mod,
            inner_mod_content = "\n".join(["    " + line for line in mod_content.split("\n")]),
        )

    service_rs_content = """
#![no_std]
#![feature(never_type)]
{mod_content}
""".format(
        mod_content = mod_content,
    )

    service_rs_file = ctx.actions.declare_file(ctx.attr.name + "_service.rs")
    ctx.actions.write(
        output = service_rs_file,
        content = service_rs_content,
    )

    return [DefaultInfo(files = depset([service_rs_file]))]

_generate_service = rule(
    implementation = _generate_service_impl,
    attrs = {
        "proto_package_name": attr.string(mandatory = True),
    },
)

def micro_rpc_service(
        name,
        srcs = [],
        deps = [],
        proto_package_name = None,
        extern_paths = {}):
    """A macro that generates a rust_library for micro RPC protos.

    Args:
        name: The name of the rust_library.
        srcs: Proto files to generate Rust code from.
        deps: Dependencies on other proto files.
        proto_package_name: The (proto) package name for files in 'srcs'.
        extern_paths: A mapping of (fully-qualified) proto package names to external crate paths.
            Also see https://docs.rs/prost-build/latest/prost_build/struct.Config.html#method.extern_path.
    """

    # Generate the cargo-build "build.rs" script.
    build_rs_gen_name = name + "_codegen"
    _generate_cargo_build(
        name = build_rs_gen_name,
        protos = srcs,
        extern_paths = extern_paths,
    )

    # Use the generated "build.rs" script to generate the micro_rpc service stubs.
    cargo_build_name = name + "_build"
    cargo_build_script(
        name = cargo_build_name,
        srcs = [":" + build_rs_gen_name],
        build_script_env = {
            "PROTOC": "$(execpath @com_google_protobuf//:protoc)",
            "DESCRIPTOR_PROTO_PATH": "$(location @com_google_protobuf//:descriptor_proto_srcs)",
        },
        data = srcs + deps + [
            "@com_google_protobuf//:descriptor_proto_srcs",
        ],
        tools = [
            "@com_google_protobuf//:protoc",
        ],
        deps = [
            "//micro_rpc_build",
            "//oak_proto_build_utils",
        ],
    )

    # Generate a "service.rs" file in which the generated stubs will be embedded (via "include!(...)").
    service_rs_gen_name = name + "_service_codegen"
    _generate_service(
        name = service_rs_gen_name,
        proto_package_name = proto_package_name,
    )

    # Compile the "service.rs" file.
    rust_library(
        name = name,
        srcs = [":" + service_rs_gen_name],
        proc_macro_deps = [
            "@oak_crates_index//:prost-derive",
        ],
        deps = [
            ":" + cargo_build_name,
            "//micro_rpc",
            "//oak_proto_rust",
            "@oak_crates_index//:prost",
        ],
    )
